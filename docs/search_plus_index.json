{"./":{"url":"./","title":"Introduction","keywords":"","body":"IntroductionIntroduction 001react简介.md 002_hello_react案例.md 003虚拟DOM的两种创建方式.md 004虚拟DOM与真实DOM.md 005_jsx语法规则.md 006_jsx小练习.md 007组件与模块.md 008开发者工具的安装.md 009函数式组件.md 010复习类相关知识.md 011类式组件.md 012对state的理解.md 013初始化state.md 014react中的事件绑定.md 015类中方法中的this.md 016解决类中this指向问题.md 017_setState的使用.md 018_state的简写方式.md 019总结state.md 020.md 021批量传递.md 022对.md 023.md 024类式组件中的构造器与.md 025函数式组件使用.md 026总结.md 027字符串形式的ref.md 028回调形式的ref.md 029回调ref中调用次数的问题.md 030createRef的使用.md 031总结ref.md 032react中的事件处理.md 033非受控组件.md 034受控组件.md 035高阶函数函数柯里化.md 036不用柯里化的写法.md 037引出生命周期.md 038生命周期(旧)组件挂载流程.md 039生命周期(旧)setState流程.md 040生命周期(旧)forceU.md 041生命周期(旧)父组件render流程.md 042总结生命周期(旧).md 043对比新旧生命周期.md 044_getDerivedStateFrom.md 045_getSna.md 046_getSna.md 047总结生命周期(新).md 048DOM的diffing算法.md 049初始化react脚手架.md 050脚手架文件介绍.md 051脚手架文件介绍_src.md 052一个简单的Hello组件.md 053样式的模块化.md 054_vscode中react插件的安装.md 055组件化编码流程.md 056TodoList案例静态组件.md 057TodoList案例动态初始化列表.md 058TodoList案例添加todo.md 059TodoList案例鼠标移入效果.md 060TodoList案例添加一个todo.md 061TodoList案例对.md 062TodoList案例删除一个todo.md 063TodoList案例实现底部功能.md 064TodoList案例总结TodoList案例.md 065脚手架配置代理方法1.md 066脚手架配置代理方法2.md 067github搜索案例静态组件.md 068github搜索案例_axios发送请求.md 069_github搜索案例展示数据.md 070github搜索案例完成案例.md 071消息订阅与发布技.md 072fetch发送请求.md 073总结github搜索案例.md 074对S.md 075对路由的理解.md 076前端路由原理.md 077路由的基本使用.md 078路由组件与一般组件.md 079_NavLink的使用.md 080封装NavLink组件.md 081Switch的使用.md 082解决样式丢失问题.md 083路由的模糊匹配与严格匹配.md 084_Redirect的使用.md 085嵌套路由.md 086向路由组件传递.md 087向路由组件传递search参数.md 088向路由组件传递state参数.md 089总结路由参数.md 090.md 091编程式路由导航.md 092withRouter的使用.md 093_BrowserRouter与HashRouter.md 094_antd的基本使用.md 095_antd样式的按需引入.md 096_antd自定义主题.md 097_redux简介.md 098_redux工作流程.md 099求和案例纯react版.md 100求和案例redux精简版.md 101求和案例redux完整版.md 102求和案例异步action版.md 103对react-redux的理解.md 104连接容器组件与UI组件.md 105_react-redux基本使用.md 106优化1简写ma.md 107优化2.md 108优化3整合UI组件与容器组件.md 109数据共享编写.md 110数据共享编写.md 111数据共享完成数据共享.md 112纯函数.md 113redux开发者工具.md 114最终版.md 115项目打包运行.md 116扩展1setState.md 117扩展2lazyLoad.md 118扩展3stateHook.md 119扩展4EffectHook.md 120扩展5RefHook.md 121扩展6Fragment.md 122扩展7Context.md 123扩展8.md 124扩展9render.md 125扩展10ErrorBoundary.md 126组件间通信方式总结.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"001_react简介.html":{"url":"001_react简介.html","title":"react简介","keywords":"","body":"001_react简介是什么谁开发的?3React特点学习React之前你要掌握的JS基础知识001_react简介 是什么 React 用于构建用户界面的JavaScript库 发送请求获取数据 处理数据(过滤,整理格式等) 操作DOM呈现页面 React是一个数据渲染为HTML视图的开源js库 谁开发的? 由Facebook开发,且开源 3 React特点 学习React之前你要掌握的JS基础知识 判断this的指向 class类 ES6语法规范 npm包管理器 原型,原型链 数组常用方法 模块化 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"002_hello_react案例.html":{"url":"002_hello_react案例.html","title":"hello_react案例","keywords":"","body":"002_hello_react案例002_hello_react案例 Document /* * 此处一定要写babel * */ // 1. 创建虚拟Dom const VDOM = Hello,React; // 此处一定不要写引号,因为不是字符串 // 这里不用加单引号,因为他是jsx // jS 和JSx 差不多 // 2. 渲染虚拟DOM到页面 // ReactDOM.render(虚拟Dom,容器) ReactDOM.render(VDOM, document.getElementById('test')); // 这个地方你不服 ReactDOM.render(VDOM, document.getElementById('test')); 这个只能写一行 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"003_虚拟DOM的两种创建方式.html":{"url":"003_虚拟DOM的两种创建方式.html","title":"虚拟DOM的两种创建方式","keywords":"","body":"003_虚拟DOM的两种创建方式003_虚拟DOM的两种创建方式 2_使用js创建虚拟DOM.html // 1. 创建虚拟Dom // const VDOM = React.createElement(标签名,标签属性,标签内容) const VDOM = React.createElement('h1',{id:'title'},'hello,React') // 2. 渲染虚拟DOM到页面 ReactDOM.render(VDOM, document.getElementById('test')); // 这个地方你不服 JSX 可以让编码人员更加简单的创建多级DOM // 1. 创建虚拟Dom const VDOM = (// 此处一定不要写引号,因为不是字符串 Hello,React ) JSX就是原生js的语法糖 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"004_虚拟DOM与真实DOM.html":{"url":"004_虚拟DOM与真实DOM.html","title":"虚拟DOM与真实DOM","keywords":"","body":"004_虚拟DOM与真实DOM004_虚拟DOM与真实DOM 3_虚拟DOM与真实DOM.html /* * 此处一定要写babel * */ // 1. 创建虚拟Dom // 此处一定不要写引号,因为不是字符串 const VDOM = ( Hello,React ) // 2. 渲染虚拟DOM到页面 ReactDOM.render(VDOM, document.getElementById('test')); // 这个地方你不服 const TDOM = document.getElementById('demo'); console.log('虚拟DOM', VDOM); console.log('真实DOM', TDOM); debugger; // 关于虚拟DOM: // 1. 本质是Object类型的对象(一般对象) // 2. 虚拟DOM比较\"轻\"(身上的属性少),真实DOM比较重 // 因为虚拟DOM是React内部在用,无需真实DOMname多的属性 // 3. 虚拟DOM最终会被React 转化为真实DOM,呈现在页面上 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"005_jsx语法规则.html":{"url":"005_jsx语法规则.html","title":"jsx语法规则","keywords":"","body":"005_jsx语法规则jsx语法规则:005_jsx语法规则 XML早期用于存储和传输数据 Tom 19 后来又有了json 了 { \"name\":\"Tom\", \"age\":\"19\" } 现在json比较NB,但是也不是也为这xml就不用了,你比如说微信公众号数据传输中还有在用的 jsx语法规则: 定义虚拟DOM时,不要写引号. 标签中混入js表达式时,用{} 样式的类名指定,不要用class,要用className. 内联样式,要用style={ {key:'value',} }的形式写 虚拟DOM,根标签只能有一个 标签必须闭合 标签首字母 若小写字母开头,则将该标签转为html中同名元素,若Html中该标签对应的无同名元素,则报错 若大写字母开头,React就去渲染对应的组件,若组件没有定义,则报错 ```html jsx语法规则 .title{ background-color: orange; width: 200px; } const myId = 'aTgUiGu' const myData = 'HeLlo,rEaCt' /* * 此处一定要写babel * */ // 1. 创建虚拟Dom// 此处一定不要写引号,因为不是字符串 const VDOM = ( {myData.toLowerCase()} {myData.toLowerCase()} 22268 22268 ) /*react-dom.development.js:500 Warning: The tag is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter. in good in div*/ // 2. 渲染虚拟DOM到页面 ReactDOM.render(VDOM, document.getElementById('test')); // 这个地方你不服 /* * jsx语法规则: * 1. 定义虚拟DOM时,不要写引号. * 2. 标签中混入js表达式时,用{} * 3. 样式的类名指定,不要用class,要用className. * 4. 内联样式,要用style={ {key:'value',} }的形式写 * 5. 虚拟DOM,根标签只能有一个 * 6. 标签必须闭合 * 7. 标签首字母 * 1. 若小写字母开头,则将该标签转为html中同名元素,若Html中该标签对应的无同名元素,则报错 * 2. 若大写字母开头,React就去渲染对应的组件,若组件没有定义,则报错 * * */ ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"006_jsx小练习.html":{"url":"006_jsx小练习.html","title":"jsx小练习","keywords":"","body":"006_jsx小练习006_jsx小练习 ```html jsx小练习.html /* * 一定主意区分: [js 语句(代码)]与[js表达式] * 1. 表达式: 一个表达式会产生一个值,可以放在任何一个需要值的地方 * 下面这些都是表达式: * 1. a * 2. a+b * 3. demo(1) * 4. arr.map() * 5. function test(){} * 2. 语句(代码): * 下面这些都是语句(代码): * 1. if(){} * 2. for(){} * 3. swtich(){case:xxx} * */ // 0. 模拟一些数据 const data = ['Angular','React','Vue'] // 吧这个纯数据加工成带有标签的数据 const obj = {\"name1\":'Angular',\"name2\":'React',\"name3\":'Vue',} const data2 = [Angular,React,Vue] // 1. 创建虚拟Dom// 此处一定不要写引号,因为不是字符串 const VDOM = ( 前端js框架列表 { data.map((item,index)=>{ return {index}>{item} }) } ); // 2. 渲染虚拟DOM到页面 ReactDOM.render(VDOM, document.getElementById('test')); // 这个地方你不服 /* * 你给react 数组 他能够帮您遍历 * 你给react 对象 他就蒙B了 * * */ ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"007_组件与模块.html":{"url":"007_组件与模块.html","title":"组件与模块","keywords":"","body":"007_组件与模块模块组件007_组件与模块 我一开始有一个index.js 然后我代码越写越多, 就可以分成 a.js,b.js 模块 理解：向外提供特定功能的js程序, 一般就是一个js文件 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。 作用：复用js, 简化js的编写, 提高js运行效率 组件 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等) 为什么要用组件：一个界面的功能更复杂 作用：复用编码, 简化项目编码, 提高运行效率 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"008_开发者工具的安装.html":{"url":"008_开发者工具的安装.html","title":"开发者工具的安装","keywords":"","body":"008_开发者工具的安装008_开发者工具的安装 打开一个 react 项目试试 这个颜色的图标表示,你是在开发环境中,并且么有打包 来看一个正常的 这里多了2个工具,一个组件,一个用于监控性能 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"009_函数式组件.html":{"url":"009_函数式组件.html","title":"函数式组件","keywords":"","body":"009_函数式组件009_函数式组件 jsx小练习.html // 1.创建函数式组件 // 循序渐进, 先写个函数 // 组件:包含页面局部功能全部代码和资源的集合 function Demo() { // return 我是用函数定义的组件(使用与简单组件的定义) } // 渲染组件到页面 ReactDOM.render(,document.getElementById('test')) function MyComponent() { console.log(this); // this 是 undefend // babel翻译完之后 开启严格模式 // 严格模式 : 禁止this指向 return 我是用函数定义的组件(使用与简单组件的定义) } // 渲染组件到页面 ReactDOM.render(,document.getElementById('test')) /* * 执行了ReactDOM.render(...之后?发生了什么? * 1. React解析组件标签,找到了MyComponent组件. * 2. 发现组件是使用函数定义的,随后调用该函数,将返回的虚拟DOM转为真实DOM,随后呈现在页面中 * */ 你写的jsx就是js的语法糖 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"010_复习类相关知识.html":{"url":"010_复习类相关知识.html","title":"复习类相关知识","keywords":"","body":"10_复习类相关知识10_复习类相关知识 本来应该直接学类式组件的 但是考虑你类都忘了 Document // 你看白雪人间,你看冰川璀璨 // 创建一个Person类 class Person { // 构造方法 构造器 constructor(name,age) { // this是类的实例对象 this.name = name; this.age = age; } // 一般方法(处理 构造方法 都是一般方法 speak() { // es6里面的模板语法 console.log(`我叫${this.name},我的年龄是${this.age}`) // 思考1 // speak方法放在 了哪里? - 类的原型对象 供实例使 // (原型链的查找规则() // 当你调用了属性不存在的属性,后者不存在的方法 // 那就要沿着原型链来查找,找下去 // 思考2 // this 是谁, 通过person 实例,调用speak时候, // speak中的this就是person实例本身 // 这也不一定,call()方法有一个功能就是更改函数中的this指向,你传谁,就改成谁 } } class Dog{} // 创建一个Person的实例对象 const p1 = new Person('tom', 18); const p2 = new Person('jerry', 19); // 控制台输出的是实例,但是前面标记了一下这个实例时由谁来产生的 console.log(p1) console.log(p2) p1.speak() p2.speak() p1.speak.call({a:1,b:2}) // 这样就要看是函数是怎么调用的 ```html Document /* * 总结: * 1. 类中的构造器不是必须写的,要对实例进行一些初始化的操作,如添加指定属性时才写. * 2. 如果A继承了B类,且A类中写了构造器,那么A类构造器中的super是必须要调用的 * 3. 类中定义的方法其实是放在了,都是放在了,类的原型对象上,供 实例去实例使用 * */ // 创建一个Person类 class Person { // 构造方法 构造器 constructor(name, age) { // this是类的实例对象 this.name = name; this.age = age; } // 一般方法(处理 构造方法 都是一般方法 speak() { // es6里面的模板语法 console.log(`我叫${this.name},我的年龄是${this.age}`); } } // 创建一个Student类,继承与Person类 class Student extends Person { // 对于学生来说,我就可以不写构造器 constructor(name, age, grade) { // 这里必须调用爸爸,超累 super(); // super必须要之前调用 this.grade = grade; } // 一般方法(处理 构造方法 都是一般方法 speak() { // es6里面的模板语法 console.log(`我叫${this.name},我的年龄是${this.age},我的年纪是${this.grade}`) } } // 创建一个Person的实例对象 const s1 = new Student('小张', 16,'高一'); console.log(s1); /* Student {name: undefined, age: undefined, grade: \"高一\"} age: undefined grade: \"高一\" name: undefined __proto__: Person * */ s1.speak() const p1 = new Person(\"是\", 45); const p2 = new Person(\"贝壳多\", 25); console.log(p1) console.log(p2) p1.speak() p2.speak() console.log(\"vicotsr\") ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"011_类式组件.html":{"url":"011_类式组件.html","title":"类式组件","keywords":"","body":"011_类式组件011_类式组件 这个构造器可以不写 但是render()是一定要写的 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"012_对state的理解.html":{"url":"012_对state的理解.html","title":"对state的理解","keywords":"","body":"012_对state的理解问题引出组件实例的三大属性之一 state012_对state的理解 问题引出 无状态的就是 简单组件 有状态的就是 复杂组件 然后现在问题来了 什么是状态? 为了解释一个状态,又引出了一个新的状态,那你就要把这个新的状态搞懂了 人的状态影响着行为 组件的状态影响 state 是 组件实例对象 中的一个属性,而不是组件的类上的 组件实例的三大属性之一 state new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"013_初始化state.html":{"url":"013_初始化state.html","title":"初始化state","keywords":"","body":"013_初始化state案例013_初始化state 案例 今天天气 ```html 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component{ constructor(props) { super(props); // 初始化状态 this.state = {isHot:false} } render() { console.log(this); // 读取状态 const {isHot} = this.state.isHot return 今天天气很{isHot ? '炎热' : '凉爽'} } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); // idea 运行 React ,alt+F2 ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"014_react中的事件绑定.html":{"url":"014_react中的事件绑定.html","title":"react中的事件绑定","keywords":"","body":"014_react中的事件绑定014_react中的事件绑定 ```html 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { constructor(props) { super(props); // 初始化状态 this.state = {isHot: false} } render() { console.log(this); // 读取状态 const {isHot} = this.state.isHot return 今天天气很{isHot ? '炎热' : '凉爽'} //onClick 要大写的C // 这里demo不能写括号 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); // document 这里你就尽量只是在这里写一次 document function demo() { alert(\"点了\"); } // idea 运行 React ,alt+F2 ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"015_类中方法中的this.html":{"url":"015_类中方法中的this.html","title":"类中方法中的this","keywords":"","body":"015_类中方法中的this局部严格模式015_类中方法中的this Document class Person{ constructor(name, age) { // this.name = name; this.age = age; } speak() { console.log(this); } } const p1 = new Person(\"张三\",18); p1.speak() ///Person {name: \"张三\", aeg: 18} // aeg: 18 // name: \"张三\" // __proto__: Object const x = p1.study //这行没有调用 // study 放在了哪里? - 类的原型对象上,供实例使用 x() // 这个直接调用 类中所有你定义的方法他在局部都开启的严格模式 类帮你自动开的 局部严格模式 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { constructor(props) { super(props); // 初始化状态 this.state = {isHot: false} } render() { console.log(this); // 读取状态 const {isHot} = this.state.isHot return 今天天气很{isHot ? '炎热' : '凉爽'} //onClick 要大写的C // 这里demo不能写括号 } // document 这里你就尽量只是在这里写一次 document changeWeather() { // changeWeather 放在哪里? - weather房子啊了原型上 ,公实例使用 // 由于changeWeather是作为onClick的回调,所以不是通过实例调用的,是直接调用 // 然后由于类中的方法默认开启了局部的严格模式,所以changeWeather中的this为undefined console.log(this); // 报错 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"016_解决类中this指向问题.html":{"url":"016_解决类中this指向问题.html","title":"解决类中this指向问题","keywords":"","body":"016_解决类中this指向问题今天天气很{isHot ? '炎热' : '凉爽'}016_解决类中this指向问题 加一句话就能解决问题 this.changeWeather = this.changeWeather.bind(this) ```html 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { constructor(props) { super(props); // 初始化状态 this.state = {isHot: false} this.changeWeather = this.changeWeather.bind(this) // 可以获取到了 // this.changeWeather 可以通过原型找到他 // this.changeWeather.bind(this) 执行完了就获得到了一个实例对象 // 然后赋值给了changeWeather } render() { console.log(this); // 读取状态 const {isHot} = this.state.isHot return 今天天气很{isHot ? '炎热' : '凉爽'} // 这里调用的是自身上的changeWeather,而不是原型上的changeWeather // this.changeWeather = this.changeWeather.bind(this) // 吧原型上的函数 挂在了 本实例 中的属性上 } changeWeather() { console.log(this); // 报错 /* * Weather {props: {…}, context: {…}, refs: {…}, updater: {…}, state: {…}, …} changeWeather: ƒ () context: {} props: {} refs: {} state: {isHot: false} updater: {isMounted: ƒ, enqueueSetState: ƒ, enqueueReplaceState: ƒ, enqueueForceUpdate: ƒ} _reactInternalFiber: FiberNode {tag: 1, key: null, stateNode: Weather, elementType: ƒ, type: ƒ, …} _reactInternalInstance: {_processChildContext: ƒ} isMounted: (...) replaceState: (...) __proto__: Component * */ } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); ```html Document function demo() { console.log(this); } demo(); demo.bind({a:1,b:2}) // 现在什么也么有 const d = demo.bind({a:1,b:2}) d(); // 这样才行 return 今天天气很{isHot ? '炎热' : '凉爽'} 这个指定的还是原型上的函数 所以还要改一下 ```html 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { constructor(props) { super(props); // 初始化状态 this.state = {isHot: false} this.changeWeather = this.changeWeather.bind(this) // 可以获取到了 // this.changeWeather 可以通过原型找到他 // this.changeWeather.bind(this) 执行完了就获得到了一个实例对象 // 然后赋值给了changeWeather this.demo = this.changeWeather // 解决changeWeather 指向的问题 } render() { console.log(this); // 读取状态 const {isHot} = this.state.isHot return 今天天气很{isHot ? '炎热' : '凉爽'} // 这里调用的是自身上的changeWeather,而不是原型上的changeWeather // this.changeWeather = this.changeWeather.bind(this) // 吧原型上的函数 挂在了 本实例 中的属性上 } changeWeather() { console.log(this); // 报错 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"017_setState的使用.html":{"url":"017_setState的使用.html","title":"setState的使用","keywords":"","body":"017_setState的使用017_setState的使用 这样就实现了 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { constructor(props) { super(props); // 初始化状态 this.state = {isHot: false} this.changeWeather = this.changeWeather.bind(this) // 可以获取到了 // this.changeWeather 可以通过原型找到他 // this.changeWeather.bind(this) 执行完了就获得到了一个实例对象 // 然后赋值给了changeWeather this.demo = this.changeWeather // 解决changeWeather 指向的问题 } render() { console.log(this); // 读取状态 const {isHot} = this.state return 今天天气很{isHot ? '炎热' : '凉爽'} // 这里调用的是自身上的changeWeather,而不是原型上的changeWeather // this.changeWeather = this.changeWeather.bind(this) // 吧原型上的函数 挂在了 本实例 中的属性上 } changeWeather() { console.log(this); // 报错 // 获取原来的isHot值 const isHot = this.state.isHot // 严重注意: 状态(state)不可直接更改,下面这行就是直接更改!!! // this.state.isHot = !isHot|; // 这是错误的写法 // 严重注意! : 状态必须使用 setState 来修改 this.setState({isHot:!isHot}); // 这是错误的写法 console.log(this.state.isHot); // 这里面改成了,布尔值已经完成切换了 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { // 构造器调用1次 constructor(props) { super(props); // 初始化状态 this.state = {isHot: false, wind: '威风'} this.changeWeather = this.changeWeather.bind(this) // 可以获取到了 // this.changeWeather 可以通过原型找到他 // this.changeWeather.bind(this) 执行完了就获得到了一个实例对象 // 然后赋值给了changeWeather this.demo = this.changeWeather // 解决changeWeather 指向的问题 } // render调用几次? - 1+n次, 1是初始化的那次 n是状态更新的次数 render() { console.log(this); // 读取状态 const {isHot,wind} = this.state return 今天天气很{isHot ? '炎热' : '凉爽'},{wind} // 这里调用的是自身上的changeWeather,而不是原型上的changeWeather // this.changeWeather = this.changeWeather.bind(this) // 吧原型上的函数 挂在了 本实例 中的属性上 } changeWeather() { console.log(this); // 报错 // 获取原来的isHot值 const isHot = this.state.isHot // 严重注意: 状态(state)不可直接更改,下面这行就是直接更改!!! // this.state.isHot = !isHot|; // 这是错误的写法 // 严重注意! : 状态必须使用 setState 来修改,且更新不是替换,而是一种合并 this.setState({isHot: !isHot}); // 这是错误的写法 // 这里面是只是改变了isHot ,还是吧wind 替换没了 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"018_state的简写方式.html":{"url":"018_state的简写方式.html","title":"state的简写方式","keywords":"","body":"018_state的简写方式来来来回顾一下然后这么写018_state的简写方式 自己写的方法,基杰上是健为事件触发后要执行的方法来使用的o 90%以上都是这样 来来来回顾一下 > class Car{ constructor(name,price) { this.name = name; this.price = price; this.wheel = 4; } // 类 中可以直接写复制语句 a = 1; // 上述dia代码的含义是: 给Car的实例对象添加一个属性,名为a,值为1 } const c1 = new Car(\"奔驰c63\",199); const c2 = new Car(\"奔驰c63\",299); console.log(c1); console.log(c2); 就是说,我这个类里面可以写成员属性 然后这么写 > 06_组件实例三大属性1_state.html.html.html // 1. 创建组件 class Weather extends React.Component { // 初始化状态 // 成员属性.,放到外面 state = {isHot: false, wind: '威风'} render() { const {isHot,wind} = this.state return 今天天气很{isHot ? '炎热' : '凉爽'},{wind} } // 自定义方法 -- 要用赋值 语句的形式+ 箭头函数 // 这样就赋值到自身了 // 剪头函数的this用的外层的this changeWeather = ()=>{ const isHot = this.state.isHot this.setState({isHot: !isHot}) // 这是错误的写法 } } // 2. 渲染 组件到页面 ReactDOM.render(, document.getElementById('test')); new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"019_总结state.html":{"url":"019_总结state.html","title":"总结state","keywords":"","body":"019_总结state理解注意019_总结state 理解 state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合) 组件被称为\"状态机\", 通过更新组件的state来更新对应的页面显示(重新渲染组件) 注意 组件中render方法中的this为组件实例对象 组件自定义的方法中this为undefined，如何解决？ a) 强制绑定this: 通过函数对象的bind() b) 箭头函数 状态数据，不能直接修改或更新 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"020_props基本使用.html":{"url":"020_props基本使用.html","title":"props基本使用","keywords":"","body":"0020_props基本使用案例0020_props基本使用 案例 06_组件实例三大属性1_state.html.html.html // 创建组件 class Person extends React.Compent { state = {name:'tom',age:18, sex: 女} render() { // 从组建外部 来给他信息,也就是不能用state 来给他数据信息 return ( 姓名: Tom 姓别: 女 年龄: 18 ) } } // 渲染组件到页面 ReactDOM.render() 然后现在就不方便吧从test2的数据传递到test里面去了 props应运而生 // 创建组件 class Person extends React.Component { state = {name: 'tom', age: \"18\", sex: \"女\"} render() { const {name, age, sex} = this.props // 从组建外部 来给他信息,也就是不能用state 来给他数据信息 return ( 姓名: {name} 姓别: {sex} 年龄: {age} ) } } // 渲染组件到页面 ReactDOM.render(, document.getElementById('test')) ReactDOM.render(, document.getElementById('test2')) ReactDOM.render(, document.getElementById('test3')) 基本写法 语法糖 const p = {name:'nancy',age:18, sex: '女'} // 渲染组件到页面 ReactDOM.render(, document.getElementById('test3')) 这个前提是你要key和后端获取的key一样 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"021_批量传递.html":{"url":"021_批量传递.html","title":"批量传递","keywords":"","body":"021_批量传递021_批量传递 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"022_对props进行限制.html":{"url":"022_对props进行限制.html","title":"对props进行限制","keywords":"","body":"02022_对props进行限制02022_对props进行限制 1_props基本使用.html.html.html.html // 创建组件 class Person extends React.Component { state = {name: 'tom', age: \"18\", sex: \"女\"} render() { const {name, age, sex} = this.props // 从组建外部 来给他信息,也就是不能用state 来给他数据信息 return ( 姓名: {name} 姓别: {sex} 年龄: {age + 1} ) } } // Person.属性规则 = { // name: '必传, 字符串' // } // 这个属性的名字不能改 // 创建的时候 找这个属性,要是有就帮你限制 // TODO 对标签属性进行类型,必要性的限制 Person.prototypes = { // PropTypes 大写的是一个React 的属性 // 注意这个string 开头是小写的 // 在React 15.xxx 有 // 在React 16 之后就被弃用了 // name:React.PropTypes.string // React 有点臃肿 这么整 name: PropTypes.string.isRequired, // 字符串 必须传 sex: PropTypes.string,// 限制rex没说必传 age: PropTypes.number,// 限制 age为数值 speak:PropTypes.func,// 限制speak为函数 } // 指定默认标签属性值 Person.defaultProps = { sex:'男', // sex默认值为难 age:18 // 年龄 默认为18 } ReactDOM.render(, document.getElementById('test1')) ReactDOM.render(, document.getElementById('test2')) ReactDOM.render(, document.getElementById('test3')) const p = {name: 'nancy', age: 18, sex: '女'} // 渲染组件到页面 ReactDOM.render(, document.getElementById('test3')) ar ReactPropTypes = { array: shim, bool: shim, func: shim, number: shim, object: shim, string: shim, symbol: shim, any: shim, arrayOf: getShim, element: shim, elementType: shim, instanceOf: getShim, node: shim, objectOf: getShim, oneOf: getShim, oneOfType: getShim, shape: getShim, exact: getShim, checkPropTypes: emptyFunctionWithReset, resetWarningCache: emptyFunction }; function 应该用funcnew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"023_props的简写方式.html":{"url":"023_props的简写方式.html","title":"props的简写方式","keywords":"","body":"023_props的简写方式023_props的简写方式 问题分析 你定义的Person类 还要在外面来进行属性的限制 这就不太好 看看能不能放到里面 // TODO 创建组件 class Person extends React.Component { state = {name: 'tom', age: \"18\", sex: \"女\"} render() { const {name, age, sex} = this.props // props 是只读的 this.props.name = 'jack' // 此行代码会报错,因为props是支队的 // 从组建外部 来给他信息,也就是不能用state 来给他数据信息 return ( 姓名: {name} 姓别: {sex} 年龄: {age + 1} ) // 年龄: {age + 1} 这个不算修改,只是一个运算,只有读的过程 } // TODO 对标签属性进行类型,必要性的限制 static prototypes = { name: PropTypes.string.isRequired, // 字符串 必须传 sex: PropTypes.string,// 限制rex没说必传 age: PropTypes.number,// 限制 age为数值 speak: PropTypes.func,// 限制speak为函数 } // TODO 指定默认标签属性值 static defaultProps = { sex: '男', // sex默认值为难 age: 18 // 年龄 默认为18 } } // TODO 渲染组件到页面 ReactDOM.render(, document.getElementById('test1')) ReactDOM.render(, document.getElementById('test2')) ReactDOM.render(, document.getElementById('test3')) const p = {name: 'nancy', age: 18, sex: '女'} ReactDOM.render(, document.getElementById('test3')) 这不就写在里面了么 现在这个类一折叠就清晰了不少了 和类相关的东西都放到了类里面 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"024_类式组件中的构造器与.html":{"url":"024_类式组件中的构造器与.html","title":"类式组件中的构造器与","keywords":"","body":"024_类式组件中的构造器与024_类式组件中的构造器与 ```javascript // TODO 创建组件 class Person extends React.Component { state = {name: 'tom', age: \"18\", sex: \"女\"} constructor(props) { // 构造器 是否接受props,石佛语传递给super,取决于: // 1. 是否希望在构造器中通过this访问props // 但是这种情况及其少见 super(props); // ??? 这个地方我传递给super()props属性 // 构造器科协可不写 console.log('constructor', this.props) // 如果我需要用this.props 也可以 直接props // props 有被传进来的, } // TODO 对标签属性进行类型,必要性的限制 static prototypes = { name: PropTypes.string.isRequired, // 字符串 必须传 sex: PropTypes.string,// 限制rex没说必传 age: PropTypes.number,// 限制 age为数值 speak: PropTypes.func,// 限制speak为函数 } // TODO 指定默认标签属性值 static defaultProps = { sex: '男', // sex默认值为难 age: 18 // 年龄 默认为18 } render() { const {name, age, sex} = this.props // props 是只读的 this.props.name = 'jack' // 此行代码会报错,因为props是支队的 // 从组建外部 来给他信息,也就是不能用state 来给他数据信息 return ( 姓名: {name} 姓别: {sex} 年龄: {age + 1} ) // 年龄: {age + 1} 这个不算修改,只是一个运算,只有读的过程 } } // TODO 渲染组件到页面 ReactDOM.render(, document.getElementById('test1')) ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"025_函数式组件使用.html":{"url":"025_函数式组件使用.html","title":"函数式组件使用","keywords":"","body":"025_函数式组件使用025_函数式组件使用 ```html 5_函数式组件使用props.html.html.html.html.html // TODO 创建组件 function Person(props) { const {name, age, sex} = props return ( 姓名: {name} 姓别: {sex} 年龄: {age} ) } // TODO 对标签属性进行类型,必要性的限制 Person.prototypes = { name: PropTypes.string.isRequired, // 字符串 必须传 sex: PropTypes.string,// 限制rex没说必传 age: PropTypes.number,// 限制 age为数值 speak: PropTypes.func,// 限制speak为函数 } // TODO 指定默认标签属性值 Person.defaultProps = { sex: '男', // sex默认值为难 age: 18 // 年龄 默认为18 } // TODO 渲染组件到页面 ReactDOM.render(, document.getElementById('test1')) ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"026_总结.html":{"url":"026_总结.html","title":"总结props","keywords":"","body":"026_总结props理解作用026_总结props props 不要写成 proto 理解 每个组件对象都会有props(properties的简写)属性 组件标签的所有属性都保存在props中 作用 通过标签属性从组件外向组件内传递变化的数据 注意: 组件内部不要修改props数据 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"027_字符串形式的ref.html":{"url":"027_字符串形式的ref.html","title":"字符串形式的ref","keywords":"","body":"027_字符串形式的ref效果理解代码027_字符串形式的ref 效果 需求: 自定义组件, 功能说明如下: 点击按钮, 提示第一个输入框中的值 当第2个输入框失去焦点时, 提示这个输入框中的值 理解 组件里面可以用ref 属性来标识自己 你只要敢用ref来标识 他就能在refs里面 包含你 代码 1_字符串形式的ref //创建组件 class Demo extends React.Component{ //展示左侧输入框的数据 showData = ()=>{ const {input1} = this.refs alert(input1.value) } //展示右侧输入框的数据 showData2 = ()=>{ const {input2} = this.refs alert(input2.value) } render(){ return( &nbsp; 点我提示左侧的数据&nbsp; ) } } //渲染组件到页面 ReactDOM.render(,document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"028_回调形式的ref.html":{"url":"028_回调形式的ref.html","title":"回调形式的ref","keywords":"","body":"028_回调形式的ref一句话代码028_回调形式的ref 前面讲的字符串形式的ref已经不被react官方所建议使用了 而且官方说,在更新有可能给他废弃掉 官方的这个教程的顺序,对于初学者不是很友好 有很多概念需要互相理解 官方文档:refs 过时 API：String 类型的 Refs 如果你之前使用过 React，你可能了解过之前的 API 中的 string 类型的 ref 属性，例如 \"textInput\"。你可以通过 this.refs.textInput 来访问 DOM 节点。我们不建议使用它，因为 string 类型的 refs 存在 一些问题。它已过时并可能会在未来的版本被移除。 注意 如果你目前还在使用 this.refs.textInput 这种方式访问 refs ，我们建议用回调函数或 createRef API 的方式代替。 一句话 字符串类型,会导致效率问题,官方没有具体说明,总之能不用就不用吧! 回调函数: 你定义的函数 你没有调用 有人调用了 代码 ```html 1_字符串形式的ref //创建组件 class Demo extends React.Component { //展示左侧输入框的数据 showData = () => { const {input1} = this alert(input1.value) } //展示右侧输入框的数据 showData2 = () => { const {input2} = this alert(input2.value) } render() { return ( this.input1 = c} type=\"text\" placeholder=\"点击按钮提示数据\"/>  点我提示左侧的数据   this.input2 = c} type=\"text\" placeholder=\"失去焦点提示数据\"/>  ) } //ref={c => this.input1 = c} 这个函数是一个回调函数 // 你只需要吧这个函数写在这里 // react 会帮你调用这个函数的 // 这里只能写ref,不能写别的,才能被扫到 // 还吧ref当前这个节点,传递进去,作为一个实参 } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"029_回调ref中调用次数的问题.html":{"url":"029_回调ref中调用次数的问题.html","title":"回调ref中调用次数的问题","keywords":"","body":"029_回调ref中调用次数的问题代码029_回调ref中调用次数的问题 官网中说: 关于回调 refs 的说明 如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。 上面说的是更新的时候调用 而一开始初始化的时候没有更新也就不会被调用2次 状态切换才是组件的更新,你正常进行的交互不算更新 //创建组件 class Demo extends React.Component { state = { isHot: false, } showInfo = () => { const {input1} = this alert(input1.value) } // changeWeather = () =>{} // 这种状态形式 changeWeather = () => { // 获取原来的状态 const {isHot} = this.isHot this.setState({isHot: !isHot}) } render() { const {isHot} = this.state return ( 今天天气很{isHot ? \"热\" : \"凉\"} { this.input1 = currentNode console.log(\"@ \", currentNode); }} type=\"text\"/> 点我提示输入的数据 改变 ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) 除了初始化的那次,每点击一次,都调用2次,第一次null,第二次才有值 弹幕: 原来是react官方的bug 回复: 兄弟,官方的bug人家不叫bug,叫特性 通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题 官方的这句话,晦涩难懂 看下面代码演示 代码 //创建组件 class Demo extends React.Component { state = { isHot: false, } showInfo = () => { const {input1} = this alert(input1.value) } // changeWeather = () =>{} // 这种状态形式 changeWeather = () => { // 获取原来的状态 const {isHot} = this.state this.setState({isHot: !isHot}) } saveInput = (c) => { this.input1 = c; console.log('@',c); }; render() { const {isHot} = this.state return ( 今天天气很{isHot ? \"热\" : \"凉\"} {/* { this.input1 = currentNode console.log(\"@ \", currentNode); }} type=\"text\"/>*/} 点我提示输入的数据 改变 ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) 官方说了,这个没什么影响 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"030_createRef的使用.html":{"url":"030_createRef的使用.html","title":"createRef的使用","keywords":"","body":"030_createRef的使用030_createRef的使用 //创建组件 class Demo extends React.Component { /* * React.createRef 调用后 可以返回一个容器,该容器可以存储被ref所标识的节点 * 该容器是专人专用的 * 里面其实她只能存储一个 * */ myRef = React.createRef(); myRef2 = React.createRef(); showData = () => { console.log(this.myRef); console.log(this.myRef.current); alert(this.myRef.current.value); } //展示右侧输入框的数据 showData2 = () => { console.log(this.myRef2); console.log(this.myRef2.current); alert(this.myRef2.current.value); } render() { return ( &nbsp; 点我提示左侧的数据 &nbsp; &nbsp; ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"031_总结ref.html":{"url":"031_总结ref.html","title":"总结ref","keywords":"","body":"031_总结ref1. 字符串形式ref一句话回调形式refcreateRef031_总结ref 1. 字符串形式ref 你只需要写名字,他自动帮你回收到 在条件允许的形式下,尽可能不要写这种字符串形式的ref 那什么是条件不允许呢 比如你写的项目工期比较紧张,你偷偷的写一些字符串形式的ref,这样也不会引发太严重的bug 一句话 能避免尽量避免 回调形式ref 函数比字符串麻烦了一些 官网说了,内联的形式他调用2次,他也无关紧要 createRef 这种最复杂 你要创建ref容器 这种也是官方最推荐的一种new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"032_react中的事件处理.html":{"url":"032_react中的事件处理.html","title":"react中的事件处理","keywords":"","body":"032_react中的事件处理032_react中的事件处理 通过onXxx属性指定事件处理函数(注意大小写) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 —————— 为了更好的兼容性 React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ———————为了的高效 通过event.target得到发生事件的DOM元素对象 ——————————不要过度使用ref React 你别动不动就写ref 有些时候,你这个ref是可以省略的 发生事件的DOM元素和你要操作的元素是一个 你就可以省略ref new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"033_非受控组件.html":{"url":"033_非受控组件.html","title":"非受控组件","keywords":"","body":"033_非受控组件033_非受控组件 理解 包含表单的组件分类 \\1. 受控组件 \\2. 非受控组件 //创建组件 class Login extends React.Component { handleSubmit = () => { const {username, password} = this; alert(`你输入的用户名是:${username.value},你输入的密码是:${password.value}`); }; render() { return ( 用户名: this.username = c} type=\"text\" name=\"username\"/> 密码: this.password = c} type=\"password\" name=\"password\"/> 登录 ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) 问题: 如何阻止页面刷新,以方便ajax来发送请求 这样就行了 //创建组件 class Login extends React.Component { handleSubmit = () => { event.preventDefault();// 阻止表单提交 const {username, password} = this; alert(`你输入的用户名是:${username.value},你输入的密码是:${password.value}`); }; render() { return ( 用户名: this.username = c} type=\"text\" name=\"username\"/> 密码: this.password = c} type=\"password\" name=\"password\"/> 登录 ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) 页面中所有输入类DOM,你要是现用现取,你就是非受控组件 现用现取: 你点登录之后: 才获取的值 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"034_受控组件.html":{"url":"034_受控组件.html","title":"受控组件","keywords":"","body":"034_受控组件受控组件代码034_受控组件 只要改变了就调用onchange 所指向的回调 受控组件 页面中所有输入类的DOM 这种输入类的DOM,随着你的输入,人家就会把东西维护到状态里面去 等你需要用的时候,直接从装填里面去取 就像Vue里面的双向数据绑定 在这里面,你不用写ref 而非受控里面,你有几个输入项,就要写几个ref 而官方说 勿过度使用 Refs 代码 ``javascript //创建组件 class Login extends React.Component { // 不能违背原则 // 最好不要在状态还么有初始化的时候就往里面放东西 // 这里定义一下 state = { username: '',// 用户名 password:''// 密码 } // 保存用户名到状态中 saveUsername = (event)=>{ console.log('@',event.target.value) this.setState({ username:event.target.value }) } // 保存密码到状态中 savePassword = (event)=>{ console.log('@',event.target.value) this.setState({ password:event.target.value }) } handleSubmit = () => { event.preventDefault();// 阻止表单提交 const {username, password} = this.state; // alert(你输入的用户名是:${username.value},你输入的密码是:${password.value}); // 这回就不用 alert(你输入的用户名是:${username},你输入的密码是:${password}`); }; render() { return ( 用户名: this.username = c} type=\"text\" name=\"username\"/> 密码: this.password = c} type=\"password\" name=\"password\"/> 登录 ) } } //渲染组件到页面 ReactDOM.render(, document.getElementById('test')) ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"035_高阶函数_函数柯里化.html":{"url":"035_高阶函数_函数柯里化.html","title":"函数柯里化","keywords":"","body":"035高阶函数函数柯里化复习高阶函数：函数的柯里化：035高阶函数函数柯里化 问题引出 你觉不觉得之前的有用瑕疵 如果这个不是登录而是注册 那username/password .... 就多了 这个是将saveFormData()的返回值作为回调 弹幕: 你秒任你秒,还是v-model好用 复习 Document let a = 'name' let obj = {} // {name:'tom'} obj[a] = 'tom' console.log(obj); 方括号的用法 //#region /* 高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。 1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。 2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。 常见的高阶函数有：Promise、setTimeout、arr.map()等等 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 function sum(a){ return(b)=>{ return (c)=>{ return a+b+c } } } */ //#endregion //创建组件 class Login extends React.Component { //初始化状态 state = { username: '', //用户名 password: '' //密码 } //保存表单数据到状态中 saveFormData = (dataType) => { // 又套了一层, 这样能够将参数传进来 // 这个能叫闭包吧!!! return (event) => { this.setState({[dataType]: event.target.value}) } } //表单提交的回调 handleSubmit = (event) => { event.preventDefault() //阻止表单提交 const {username, password} = this.state alert(`你输入的用户名是：${username},你输入的密码是：${password}`) } render() { return ( 用户名： 密码： 登录 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) 不要纠结有没有小括号,核心是你要将一个函数交给回调 //#region 加这个东西就能够折叠了 高阶函数： 如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。 1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。 2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。 常见的高阶函数有：Promise、setTimeout、arr.map()等等 函数的柯里化： 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 /* function sum(a,b,c){ return a+b+c } */ function sum(a){ return(b)=>{ return (c)=>{ return a+b+c } } } const result = sum(1)(2)(3) console.log(result); 你这么写 科里化 呵呵 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"036_不用柯里化的写法.html":{"url":"036_不用柯里化的写法.html","title":"不用柯里化的写法","keywords":"","body":"036_不用柯里化的写法036_不用柯里化的写法 就是直接写一个匿名函数,就不至于要套一层,来传递参数了 //创建组件 class Login extends React.Component { //初始化状态 state = { username: '', //用户名 password: '' //密码 } //保存表单数据到状态中 saveFormData = (dataType, event) => { this.setState({[dataType]: event.target.value}) } //表单提交的回调 handleSubmit = (event) => { event.preventDefault() //阻止表单提交 const {username, password} = this.state alert(`你输入的用户名是：${username},你输入的密码是：${password}`) } render() { return ( 用户名： this.saveFormData('username', event)} type=\"text\" name=\"username\"/> 密码： this.saveFormData('password', event)} type=\"password\" name=\"password\"/> 登录 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"037_引出生命周期.html":{"url":"037_引出生命周期.html","title":"引出生命周期","keywords":"","body":"037_引出生命周期将生命周期方法添加到 Class 中037_引出生命周期 如果你学了React ,但是你对于他的声明周期一无所知 那约等于你没有学习React // 从页面上移除一个组件// 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 将生命周期方法添加到 Class 中 在具有许多组件的应用程序中，当组件被销毁时释放所占用的资源是非常重要的。 当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）”。 同时，当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（unmount）”。 // 创建组件 class Life extends React.Component{ state = {opacity: 1} death = () => { // 从页面上移除一个组件 // 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 // 卸载组件 unmountComponentAtNode ReactDOM.unmountComponentAtNode(document.getElementById('test')) }; render() { // 循环定时器 setInterval(() => { // 获取源状态 let {opacity} = this.state; // 减小0.1 opacity -= 0.1; if (opacity React 学不会怎么办 不活了 ) } } // 渲染组件 ReactDOM.render(,document.getElementById('test')) 引发无线递归,不断创建定时器 你的cpu温度逐渐上升 render()调用,指数增长 // 创建组件 class Life extends React.Component{ constructor() { super(); setInterval(() => { // 获取源状态 let {opacity} = this.state; // 减小0.1 opacity -= 0.1; if (opacity { // 从页面上移除一个组件 // 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 // 卸载组件 unmountComponentAtNode ReactDOM.unmountComponentAtNode(document.getElementById('test')) }; render() { // 循环定时器 return( React 学不会怎么办 不活了 ) } } // 渲染组件 ReactDOM.render(,document.getElementById('test')) 现在写在构造里面了,还是不太好 // 创建组件 class Life extends React.Component{ state = {opacity: 1} death = () => { // 从页面上移除一个组件 // 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 // 卸载组件 unmountComponentAtNode ReactDOM.unmountComponentAtNode(document.getElementById('test')) }; // / 内置 // 组件挂载完毕,调用,而且只是调用一次 componentDidMount() { setInterval(() => { // 获取源状态 let {opacity} = this.state; // 减小0.1 opacity -= 0.1; if (opacity React 学不会怎么办 不活了 ) } } // 渲染组件 ReactDOM.render(,document.getElementById('test')) 现在问题解决了么? oh不,还有问题 现在点控制台,报错 react_devtools_backend.js:2450 Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method. in Life 我不能够,在组件没了之后在帮你更新 所以我们要清空定时器 // 创建组件 class Life extends React.Component{ state = {opacity: 1} death = () => { // 清除定时器 clearInterval(this.timer); // 从页面上移除一个组件 // 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 // 卸载组件 unmountComponentAtNode ReactDOM.unmountComponentAtNode(document.getElementById('test')) }; // 内置 // 组件挂载完毕,调用,而且只是调用一次 componentDidMount() { this.timer = setInterval(() => { // 获取源状态 let {opacity} = this.state; // 减小0.1 opacity -= 0.1; if (opacity React 学不会怎么办 不活了 ) } } // 渲染组件 ReactDOM.render(,document.getElementById('test')) 这回就ok了,还能优化呢 使用componentWillUnmount()函数 // 创建组件 class Life extends React.Component{ state = {opacity: 1} death = () => { // 从页面上移除一个组件 // 渲染是render, 移除是??? // 渲染也可以说成是把组件挂载到页面上 // 卸载组件 unmountComponentAtNode ReactDOM.unmountComponentAtNode(document.getElementById('test')) }; // 内置 // 组件挂载完毕,调用,而且只是调用一次 componentDidMount() { this.timer = setInterval(() => { // 获取源状态 let {opacity} = this.state; // 减小0.1 opacity -= 0.1; if (opacity React 学不会怎么办 不活了 ) } } // 渲染组件 ReactDOM.render(,document.getElementById('test')) 这回你就明白了,React会在合适的时间点来干一些合适的事情儿 * 生命周期回调函数生命周期钩子函数生命周期函数生命周期钩子 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"038_生命周期旧_组件挂载流程.html":{"url":"038_生命周期旧_组件挂载流程.html","title":"生命周期(旧)_组件挂载流程","keywords":"","body":"038生命周期(旧)组件挂载流程038生命周期(旧)组件挂载流程 理解: 组件从创建到死亡她会经历一些特定的阶段 React组件中包含一系列钩子函数(声明周期函数),会在特定的时刻调用 我们在定义组件时,会在特定的声明周期回调函数中,做特定的工作. 声明周期函数(钩子) 什么时候调用,和你写在哪儿么有关系 案例 // 定义组件 class Count extends React.Component { // 初始化状态 state = {count: 0} // 这里count 和类名 Count 没关系 //加1按钮的回调 add = () => { // 获取原来的状态 const {count} = this.state; // 更新状态 this.setState({count: count + 1}) }; render() { const {count} = this.state; return ( 当前求和为:{count} 点我+1 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) 测试顺序 // 定义组件 class Count extends React.Component { // 第一个调用的当然是构造器 constructor(props) { console.log(\"count-constructor\"); super(props); // 初始化状态 this.state = {count: 0} // 这里count 和类名 Count 没关系 } //加1按钮的回调 add = () => { // 获取原来的状态 const {count} = this.state; // 更新状态 this.setState({count: count + 1}) }; // 组件将要挂载的钩子 componentWillMount() { console.log(\"componentWillMount\"); } // 组件挂载完毕的钩子 componentDidMount() { console.log(\"componentDitMount\") } render() { console.log(\"render\") const {count} = this.state; return ( 当前求和为:{count} 点我+1 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) Inline Babel script:8 count-constructor Inline Babel script:27 componentWillMount Inline Babel script:35 render Inline Babel script:32 componentDitMount new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"039_生命周期旧_setState流程.html":{"url":"039_生命周期旧_setState流程.html","title":"生命周期(旧)_setState流程","keywords":"","body":"039_生命周期(旧)_setState流程039_生命周期(旧)_setState流程 // 定义组件 class Count extends React.Component { // 第一个调用的当然是构造器 constructor(props) { console.log(\"count-constructor\"); super(props); // 初始化状态 this.state = {count: 0} // 这里count 和类名 Count 没关系 } //加1按钮的回调 add = () => { // 获取原来的状态 const {count} = this.state; // 更新状态 this.setState({count: count + 1}) }; // 卸载组件按钮的回调 death = () => { ReactDOM.unmountComponentAtNode(document.getElementById(\"test\")) } // 组件将要挂载的钩子 componentWillMount() { console.log(\"componentWillMount\"); } // 组件挂载完毕的钩子 componentDidMount() { console.log(\"componentDitMount\") } /* * 你如果不写,底层默认帮你返回一个true,如果您i要是自己写,一定要返回布尔 * */ // 控制组件更新的阀门 shouldComponentUpdate() { console.log(\"shouldComponentUpdate\") // 这里 必须要返回一个 布尔值 return true; // 返回true 就能正常走 // return false; // 返回 f 就凉了 } // 组件将要更新的钩子 componentWillUpdate() { console.log(\"componentWillUpdate\"); } // 组件将要更新的钩子 componentDidUpdate() { console.log(\"componentDidUpdate\"); } render() { console.log(\"render\") const {count} = this.state; return ( 当前求和为:{count} 点我+1 西在 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"040_生命周期旧_forceUpdate.html":{"url":"040_生命周期旧_forceUpdate.html","title":"生命周期旧_forceUpdate","keywords":"","body":"040_生命周期(旧)_forceU040_生命周期(旧)_forceU 强制更新 你可以不对组件里面的状态做更改,也可以更新组件的渲染 forceUpdate() 正常更新需要走阀门,但是强制更新,他不走阀门 // 定义组件 class Count extends React.Component { // 第一个调用的当然是构造器 constructor(props) { console.log(\"count-constructor\"); super(props); // 初始化状态 this.state = {count: 0} // 这里count 和类名 Count 没关系 } //加1按钮的回调 add = () => { // 获取原来的状态 const {count} = this.state; // 更新状态 this.setState({count: count + 1}) }; // 卸载组件按钮的回调 death = () => { ReactDOM.unmountComponentAtNode(document.getElementById(\"test\")) }; // 强制组件按钮的回调 force = () => { this.forceUpdate(); // 阀门关了也能更新 }; // 组件将要挂载的钩子 componentWillMount() { console.log(\"componentWillMount\"); } // 组件挂载完毕的钩子 componentDidMount() { console.log(\"componentDitMount\") } /* * 你如果不写,底层默认帮你返回一个true,如果您i要是自己写,一定要返回布尔 * */ // 控制组件更新的阀门 shouldComponentUpdate() { console.log(\"shouldComponentUpdate\"); // 这里 必须要返回一个 布尔值 return true; // 返回true 就能正常走 // return false; // 返回 f 就凉了 } // 组件将要更新的钩子 componentWillUpdate() { console.log(\"componentWillUpdate\"); } // 组件将要更新的钩子 componentDidUpdate() { console.log(\"componentDidUpdate\"); } render() { console.log(\"render\") const {count} = this.state; return ( 当前求和为:{count} 点我+1 西在 强制 ) } } //渲染组件 ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"041_生命周期旧_父组件render流程.html":{"url":"041_生命周期旧_父组件render流程.html","title":"生命周期(旧)_父组件render流程","keywords":"","body":"041生命周期(旧)父组件render流程041生命周期(旧)父组件render流程 componentWillReceiveProps被调用的时机 有人建议他改成 componentWillReceiveNewProps 以为 组件将要接收新的 props ,一开始第一次传的不算 但是我这边我还是调用了 class A extends React.Component { // 存储骑车的名字 // 初始化状态 state = {carName: 'BMW'} changeCar = () => { // 更新车你的信息 this.setState({carName: \"奥迪\"}) }; render() { return ( 我是A组件 换车 {/*然后B组件来展示这个骑车的信息*/} ) } } class B extends React.Component { // 这个有瑕疵 /* * 有人建议他改成 componentWillReceiveNewProps * 以为 组件将要接收新的 props ,一开始第一次传的不算 * 但是我这边我还是调用了 * */ // 所以应该叫做: 组件将要接收新的props的钩子 componentWillReceiveProps(props) { console.log(\"componentWillReceiveProps\", props); } // 控制组件更新的阀门 shouldComponentUpdate() { console.log(\"shouldComponentUpdate\"); // 这里 必须要返回一个 布尔值 return true; // 返回true 就能正常走 // return false; // 返回 f 就凉了 } // 组件将要更新的钩子 componentWillUpdate() { console.log(\"componentWillUpdate\"); } // 组件将要更新的钩子 componentDidUpdate() { console.log(\"componentDidUpdate\"); } render() { console.log(\"render\"); return ( 我是B组件,接收到的车是:{this.props.carName} ) } } // A是父组件 B是子组件 //渲染组件 ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"042_总结生命周期旧.html":{"url":"042_总结生命周期旧.html","title":"总结生命周期(旧)","keywords":"","body":"042_总结生命周期(旧)042_总结生命周期(旧) 生命周期的三个阶段（新） 初始化阶段: 由ReactDOM.render()触发---初次渲染 constructor() getDerivedStateFromProps render() componentDidMount() ===> 常用, 一般在这个钩子里面做一些初始化的事情,例如: 开启定时器 发送网络请求 订阅消息 更新阶段: 由组件内部this.setSate()或父组件重新render触发 getDerivedStateFromProps shouldComponentUpdate() render()===>必须要用 getSnapshotBeforeUpdate componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 componentWillUnmount() ===> 常用 一般在这个钩子里面做一些收尾的事情,例如: 关闭定时器 取消订阅 网络请求(这个没有,你都发出去网络请求了,还怎么着) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"043_对比新旧生命周期.html":{"url":"043_对比新旧生命周期.html","title":"对比新旧生命周期","keywords":"","body":"043_对比新旧生命周期我不能跟你讲最新的声明周期引入新版本在新版本里面对比一下旧的图新的图对比挂载时新的声明周期 VS 旧的声明周期043_对比新旧生命周期 我不能跟你讲最新的声明周期 咱先更新一下react最新版本 看看官网的CDN连接 给你推荐一个网站:bootcdn 这个网站前端的cdn都有 引入新版本 在新版本的里面,原来的钩子有警告了 大概的意思就是,componentWillMount 这个钩子被重命名了,而且不被推荐使用了 babel.min.js:24779 You are using the in-browser Babel transformer. Be sure to precompile your scripts for production - https://babeljs.io/docs/setup/ u @ babel.min.js:24779 f @ babel.min.js:78 (anonymous) @ babel.min.js:206 DevTools failed to load SourceMap: Could not load content for chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/injectGlobalHook.js.map: HTTP error: status code 404, net::ERR_UNKNOWN_URL_SCHEME Inline Babel script:7 count-constructor Inline Babel script:35 componentWillMount Inline Babel script:66 render react-dom.development.js:63 Warning: componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details. * Move code with side effects to componentDidMount, and set initial state in the constructor. * Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder. Please update the following components: Count printWarning @ react-dom.development.js:63 warn @ react-dom.development.js:29 ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings @ react-dom.development.js:11786 flushRenderPhaseStrictModeWarningsInDEV @ react-dom.development.js:24025 commitRootImpl @ react-dom.development.js:23209 unstable_runWithPriority @ react.development.js:2997 runWithPriority$1 @ react-dom.development.js:11528 commitRoot @ react-dom.development.js:23194 performSyncWorkOnRoot @ react-dom.development.js:22521 scheduleUpdateOnFiber @ react-dom.development.js:22079 updateContainer @ react-dom.development.js:25699 (anonymous) @ react-dom.development.js:26246 unbatchedUpdates @ react-dom.development.js:22627 legacyRenderSubtreeIntoContainer @ react-dom.development.js:26245 render @ react-dom.development.js:26330 (anonymous) @ Inline Babel script:122 i @ babel.min.js:24730 r @ babel.min.js:24753 o @ babel.min.js:24770 u @ babel.min.js:24779 f @ babel.min.js:78 (anonymous) @ babel.min.js:206 react-dom.development.js:63 Warning: componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details. * Move data fetching code or side effects to componentDidUpdate. * Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder. Please update the following components: Count printWarning @ react-dom.development.js:63 warn @ react-dom.development.js:29 ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings @ react-dom.development.js:11798 flushRenderPhaseStrictModeWarningsInDEV @ react-dom.development.js:24025 commitRootImpl @ react-dom.development.js:23209 unstable_runWithPriority @ react.development.js:2997 runWithPriority$1 @ react-dom.development.js:11528 commitRoot @ react-dom.development.js:23194 performSyncWorkOnRoot @ react-dom.development.js:22521 scheduleUpdateOnFiber @ react-dom.development.js:22079 updateContainer @ react-dom.development.js:25699 (anonymous) @ react-dom.development.js:26246 unbatchedUpdates @ react-dom.development.js:22627 legacyRenderSubtreeIntoContainer @ react-dom.development.js:26245 render @ react-dom.development.js:26330 (anonymous) @ Inline Babel script:122 i @ babel.min.js:24730 r @ babel.min.js:24753 o @ babel.min.js:24770 u @ babel.min.js:24779 f @ babel.min.js:78 (anonymous) @ babel.min.js:206 Inline Babel script:40 componentDitMount DevTools failed to load SourceMap: Could not load content for chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/contentScript.js.map: HTTP error: status code 404, net::ERR_UNKNOWN_URL_SCHEME DevTools failed to load SourceMap: Could not load content for chrome-extension://fmkadmapgofadopljbjfkapdkoienihi/build/react_devtools_backend.js.map: HTTP error: status code 404, net::ERR_UNKNOWN_URL_SCHEME 在18.x版本里面,可能你要写UNSAFE_开头的才能工作了 你现在不加UNSAFE_componentWillMount 他就不能工作了 在新版本里面 componentWillReceiveProps componentWillUpdate componentWillUpdate 你就怎么记,带有will的都要加上UNSAFE_前缀 来看官方怎么说,然后你就会发现React在搞一个叫异步渲染之更新的东西. 我们得到最重要的经验是，过时的组件生命周期往往会带来不安全的编码实践，具体函数如下： componentWillMount componentWillReceiveProps componentWillUpdate 这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后 说白了就是,这3个钩子,他设计的没有什么存在感,然后总有一些编码人员他在不太适合用的时候,他往里面写东西 他就觉得他这个被滥用了 他用UNSAFE_提示你轻易不要用 这回还行,还能用,下次就直接不加前缀不让你用了 你真正开发的时候你就,知道了,这3个钩子基本上不用 所以你就响应React的号召 现在只是提高了一些你使用的难度 网上还有很多人说了:这3个钩子即将废弃,也是不无道理的 对比一下 旧的图 新的图 对比 挂载时 新的声明周期 VS 旧的声明周期 废弃了3个钩子 componentWillMount componentWillReceiveProps componentWillUpdate 产生了2个新的钩子 getDerivedStateFromProps getSnapshotBeforeUpdate 在官方文档中说了,这2个新的用法极其罕见,所以你就当不知道 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"044_getDerivedStateFromProps.html":{"url":"044_getDerivedStateFromProps.html","title":"getDerivedStateFromProps","keywords":"","body":"044_getDerivedStateFromProps然后开始测试一句话044_getDerivedStateFromProps getDerivedStateFromProps翻译为获取派生状态从props中 然后开始测试 你家这么一行代码 getDerivedStateFromProps() { // 如果当真 console.log(\"getDerivedStateFromProps\"); } 然后就有警告了 Warning: Count: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method. at Count (:17:9) 说明这个钩子不应该给实例用 static getDerivedStateFromProps() { // 如果当真 console.log(\"getDerivedStateFromProps\"); } 现在报警告这个 Warning: Count.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined. at Count (:17:9) 就是说 你必须要给我返回, 1. 返回状态对象 2, 返回 null 然而你现在返回 undefined 就不行 代码成这样了 static getDerivedStateFromProps() { // 如果当真 console.log(\"get|DerivedStateFromProps\"); return null; } 那他让我返回状态对象 我就按他说的来 static getDerivedStateFromProps() { // 如果当真 console.log(\"get|DerivedStateFromProps\"); return {count:108}; } 然后你会发现你的页面 也就是说这个函数的返回值能够指定状态,但是我现在+1 坏了 换句话说,你这个一单返回这个状态对象,他就不能更改了,(状态更新失效) 所以什么是派生? static getDerivedStateFromProps(props) { // 如果当真 console.log(\"get|DerivedStateFromProps\",props); return {count:108}; } 现在打印是空 那我要是给 //渲染组件 ReactDOM.render(, document.getElementById('test')) 在这个函数里面 把 props 返回了,所以说,这个props就当成了 状态用了 什么时候用?呢,看一下官方说的 getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。 此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 `` 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。 你只要把上述代码加上后,你的状态在任何时候都等于props,那也就是你的更改啊,什么+1啊都失去效果了 派生状态会导致代码冗余，并使组件难以维护。 确保你已熟悉这些简单的替代方案： 如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate。 如果只想在 prop 更改时重新计算某些数据，请使用 memoization helper 代替。 如果你想在 prop 更改时“重置”某些 state，请考虑使组件完全受控或使用 key 使组件完全不受控 代替。 一句话 了解即可 // 若state 的值在任何时候都取决于props,那么可以使用getDerivedStateFromProps static getDerivedStateFromProps(props,state) { // 如果当真 console.log(\"get|DerivedStateFromProps\",props,state); return {count:108}; } // 为什么不是必须要用呢,你看你要是 状态state都是固定的了,那你直接在构造器里面用 // 那不也成了么 还是不用 这个函数啊 // 就这钩子, 他没啥太大意义,就给他干掉都行 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"045_getSnapshotBeforeUpdate.html":{"url":"045_getSnapshotBeforeUpdate.html","title":"getSnapshotBeforeUpdate","keywords":"","body":"045 getSnapshotBeforeUpdate看一下新的图旧的图翻译getSnapshotBeforeUpdate()045 getSnapshotBeforeUpdate getSnapshotBeforeUpdate比之前内个有点儿意义,刚才内个内写完了还违背了一些原则,有搭建了一些环境才搞出来了,然后还引发出了一些问题,就就就 ... 就™离谱 看一下新的图 旧的图 我先把上一个函数 ,让他返回null,但是我还不给他删除掉,不然你总是感觉没有走式的 static getDerivedStateFromProps(props,state) { // 如果当真 console.log(\"get|DerivedStateFromProps\",props,state); return null; } 翻译 Snapshot ==> 快照 getSnapshotBeforeUpdate ===> 在更新之前获取快照 上代码测试 getSnapshotBeforeUpdate() { console.log(\"getSnapshotBeforeUpdate\"); } 然后他报错 react_devtools_backend.js:2450 Warning: Count.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined. at Count (:17:9) 解决一下 getSnapshotBeforeUpdate() { console.log(\"getSnapshotBeforeUpdate\"); return null; } 所以看官方这么说的 getSnapshotBeforeUpdate() getSnapshotBeforeUpdate(prevProps, prevState) getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。 此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。 应返回 snapshot 的值（或 null）。new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"046_getSnapshotBeforeUpadate案例.html":{"url":"046_getSnapshotBeforeUpadate案例.html","title":"getSnapshotBeforeUpadate案例","keywords":"","body":"046_getSnapshotBeforeUpadate案例046_getSnapshotBeforeUpadate案例 class NewsList extends React.Component { state = {newsArr: []} // 组件挂载完毕的钩子 componentDidMount() { setInterval(() => { //获取原状态 const {newsArr} = this.state //模拟一条新闻 const news = '新闻' + (newsArr.length + 1) //更新状态 this.setState({newsArr: [news, ...newsArr]}) }, 1000); } getSnapshotBeforeUpdate() { // 返回 高度 return this.refs.list.scrollHeight } componentDidUpdate(preProps, preState, height) { this.refs.list.scrollTop += this.refs.list.scrollHeight - height } render() { return ( { this.state.newsArr.map((n, index) => { return {n} }) } ) } } ReactDOM.render(, document.getElementById('test')) new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"047_总结生命周期新.html":{"url":"047_总结生命周期新.html","title":"总结生命周期(新)","keywords":"","body":"047_总结生命周期(新)047_总结生命周期(新) 2.6.5. 重要的勾子 render：初始化渲染或更新渲染调用 componentDidMount：开启监听, 发送ajax请求 componentWillUnmount：做一些收尾工作, 如: 清理定时器 2.6.6. 即将废弃的勾子 componentWillMount componentWillReceiveProps componentWillUpdatenew Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"048_DOM的diffing算法.html":{"url":"048_DOM的diffing算法.html","title":"DOM的diffing算法","keywords":"","body":"048_DOM的diffing算法048_DOM的diffing算法 class Time extends React.Component { state = {date: new Date()} componentDidMount () { setInterval(() => { this.setState({ date: new Date() }) }, 1000) } render () { return ( hello 现在是：{this.state.date.toTimeString()} ) } } ReactDOM.render(,document.getElementById('test')) /* 经典面试题: 1). react/vue中的key有什么作用？（key的内部原理是什么？） 2). 为什么遍历列表时，key最好不要用index? 1. 虚拟DOM中key的作用： 1). 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。 2). 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： a. 旧虚拟DOM中找到了与新虚拟DOM相同的key： (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM b. 旧虚拟DOM中未找到与新虚拟DOM相同的key 根据数据创建新的真实DOM，随后渲染到到页面 2. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==> 界面有问题。 3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作， 仅用于渲染列表用于展示，使用index作为key是没有问题的。 3. 开发中如何选择key?: 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果确定只是简单的展示数据，用index也是可以的。 */ /* 慢动作回放----使用index索引值作为key 初始数据： {id:1,name:'小张',age:18}, {id:2,name:'小李',age:19}, 初始的虚拟DOM： 小张---18 小李---19 更新后的数据： {id:3,name:'小王',age:20}, {id:1,name:'小张',age:18}, {id:2,name:'小李',age:19}, 更新数据后的虚拟DOM： 小王---20 小张---18 小李---19 ----------------------------------------------------------------- 慢动作回放----使用id唯一标识作为key 初始数据： {id:1,name:'小张',age:18}, {id:2,name:'小李',age:19}, 初始的虚拟DOM： 小张---18 小李---19 更新后的数据： {id:3,name:'小王',age:20}, {id:1,name:'小张',age:18}, {id:2,name:'小李',age:19}, 更新数据后的虚拟DOM： 小王---20 小张---18 小李---19 */ class Person extends React.Component{ state = { persons:[ {id:1,name:'小张',age:18}, {id:2,name:'小李',age:19}, ] } add = ()=>{ const {persons} = this.state const p = {id:persons.length+1,name:'小王',age:20} this.setState({persons:[p,...persons]}) } render(){ return ( 展示人员信息 添加一个小王 使用index（索引值）作为key { this.state.persons.map((personObj,index)=>{ return {personObj.name}---{personObj.age} }) } 使用id（数据的唯一标识）作为key { this.state.persons.map((personObj)=>{ return {personObj.name}---{personObj.age} }) } ) } } ReactDOM.render(,document.getElementById('test') new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"049_初始化react脚手架.html":{"url":"049_初始化react脚手架.html","title":"初始化react脚手架","keywords":"","body":"049_初始化react脚手架049_初始化react脚手架 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"050_脚手架文件介绍_.html":{"url":"050_脚手架文件介绍_.html","title":"脚手架文件介绍_","keywords":"","body":"050脚手架文件介绍050脚手架文件介绍 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"051_脚手架文件介绍_src.html":{"url":"051_脚手架文件介绍_src.html","title":"脚手架文件介绍_src","keywords":"","body":"051_脚手架文件介绍_src051_脚手架文件介绍_src App.js 创建了一个组件,内个组件就叫做app new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"052_一个简单的Hello组件.html":{"url":"052_一个简单的Hello组件.html","title":"一个简单的Hello组件","keywords":"","body":"052_一个简单的Hello组件052_一个简单的Hello组件 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"053_样式的模块化.html":{"url":"053_样式的模块化.html","title":"样式的模块化","keywords":"","body":"053_样式的模块化053_样式的模块化 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"054_vscode中react插件的安装.html":{"url":"054_vscode中react插件的安装.html","title":"vscode中react插件的安装","keywords":"","body":"054_vscode中react插件的安装054_vscode中react插件的安装 vscode 搜索 插件 React 第二个 安装了这个 rcc: react class component rfc: react function component 就可以用代码模板来直接生成一些固定的格式的代码片段了 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"055_组件化编码流程.html":{"url":"055_组件化编码流程.html","title":"组件化编码流程","keywords":"","body":"055_组件化编码流程055_组件化编码流程 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"056_TodoList案例_静态组件.html":{"url":"056_TodoList案例_静态组件.html","title":"静态组件","keywords":"","body":"056TodoList案例静态组件056TodoList案例静态组件 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"057_TodoList案例_动态初始化列表.html":{"url":"057_TodoList案例_动态初始化列表.html","title":"动态初始化列表","keywords":"","body":"057TodoList案例动态初始化列表057TodoList案例动态初始化列表 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"058_TodoList案例_添加todo.html":{"url":"058_TodoList案例_添加todo.html","title":"添加todo","keywords":"","body":"058TodoList案例添加todo058TodoList案例添加todo new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"059_TodoList案例_鼠标移入效果.html":{"url":"059_TodoList案例_鼠标移入效果.html","title":"鼠标移入效果","keywords":"","body":"059TodoList案例鼠标移入效果059TodoList案例鼠标移入效果 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"060_TodoList案例_添加一个todo.html":{"url":"060_TodoList案例_添加一个todo.html","title":"添加一个todo","keywords":"","body":"060TodoList案例添加一个todo060TodoList案例添加一个todo new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"061_TodoList案例_对props进行限制.html":{"url":"061_TodoList案例_对props进行限制.html","title":"对props进行限制","keywords":"","body":"061TodoList案例对props进行限制061TodoList案例对props进行限制new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"062_TodoList案例_删除一个todo.html":{"url":"062_TodoList案例_删除一个todo.html","title":"删除一个todo","keywords":"","body":"062TodoList案例删除一个todo062TodoList案例删除一个todo delete 是一个关键字,不能定义成变量的名称 删除一个TODO new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"063_TodoList案例_实现底部功能.html":{"url":"063_TodoList案例_实现底部功能.html","title":"实现底部功能","keywords":"","body":"063TodoList案例实现底部功能063TodoList案例实现底部功能 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"064_TodoList案例_总结TodoList案例.html":{"url":"064_TodoList案例_总结TodoList案例.html","title":"总结TodoList案例","keywords":"","body":"064TodoList案例总结TodoList案例总结:064TodoList案例总结TodoList案例 TodoList 总结: 拆分组件、实现静态组件，注意：className、style的写法 动态初始化列表，如何确定将数据放在哪个组件的state中？ 某个组件使用：放在其自身的state中 某些组件使用：放在他们共同的父组件state中（官方称此操作为：状态提升） 关于父子之间通信： 父组件】给【子组件】传递数据：通过props传递 子组件】给【父组件】传递数据：通过props传递，要求父提前给子传递一个函数 , 然后子组件通过调用这个函数(以参数的形式将数据传递回父组件) 注意defaultChecked 和 checked的区别，类似的还有：defaultValue 和 value 状态在哪里，操作状态的方法就在哪里 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"065_脚手架配置代理_方法1.html":{"url":"065_脚手架配置代理_方法1.html","title":"脚手架配置代理_方法1","keywords":"","body":"065脚手架配置代理方法1react ajax065脚手架配置代理方法1 react ajax React本身只关注于界面, 并不包含发送ajax请求的代码 前端应用需要通过ajax请求与后台进行交互(json数据) react应用中需要集成第三方ajax库(或自己封装) 你为什么学习React ? 是要尽量减少自己去操作DOM 你只是更新状态,该数据,React 帮你是更新然后渲染页面 React 的核心就是你别自己操作DOM 所以不建议用JQ,在React里面导入 脚手架配置代理 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 21:04:17 "},"066_脚手架配置代理_方法2.html":{"url":"066_脚手架配置代理_方法2.html","title":"脚手架配置代理_方法2","keywords":"","body":"066脚手架配置代理方法2066脚手架配置代理方法2 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"067_github搜索案例_静态组件.html":{"url":"067_github搜索案例_静态组件.html","title":"github搜索案例_静态组件","keywords":"","body":"067github搜索案例静态组件067github搜索案例静态组件 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"068_github搜索案例_axios发送请求.html":{"url":"068_github搜索案例_axios发送请求.html","title":"github搜索案例_axios发送请求","keywords":"","body":"068_github搜索案例_axios发送请求068_github搜索案例_axios发送请求 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"069_github搜索案例_展示数据.html":{"url":"069_github搜索案例_展示数据.html","title":"github搜索案例_展示数据","keywords":"","body":"069github搜索案例展示数据069github搜索案例展示数据 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"070_github搜索案例_完成案例.html":{"url":"070_github搜索案例_完成案例.html","title":"github搜索案例_完成案例","keywords":"","body":"070github搜索案例完成案例070github搜索案例完成案例 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"071_消息订阅与发布技_.html":{"url":"071_消息订阅与发布技_.html","title":"消息订阅与发布技_","keywords":"","body":"071消息订阅与发布技071消息订阅与发布技 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"072_fetch发送请求.html":{"url":"072_fetch发送请求.html","title":"fetch发送请求","keywords":"","body":"072_fetch发送请求072_fetch发送请求 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"073_总结github搜索案例.html":{"url":"073_总结github搜索案例.html","title":"总结github搜索案例","keywords":"","body":"073_总结github搜索案例073_总结github搜索案例 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"074_对S.html":{"url":"074_对S.html","title":"对S","keywords":"","body":"074_对S074_对S new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"075_对路由的理解.html":{"url":"075_对路由的理解.html","title":"对路由的理解","keywords":"","body":"075_对路由的理解075_对路由的理解 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"076_前端路由原理.html":{"url":"076_前端路由原理.html","title":"前端路由原理","keywords":"","body":"076_前端路由原理076_前端路由原理 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"077_路由的基本使用.html":{"url":"077_路由的基本使用.html","title":"路由的基本使用","keywords":"","body":"077_路由的基本使用077_路由的基本使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"078_路由组件与一般组件.html":{"url":"078_路由组件与一般组件.html","title":"路由组件与一般组件","keywords":"","body":"078_路由组件与一般组件078_路由组件与一般组件 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"079_NavLink的使用.html":{"url":"079_NavLink的使用.html","title":"NavLink的使用","keywords":"","body":"079_NavLink的使用079_NavLink的使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"080_封装NavLink组件.html":{"url":"080_封装NavLink组件.html","title":"封装NavLink组件","keywords":"","body":"080_封装NavLink组件080_封装NavLink组件 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"081_Switch的使用.html":{"url":"081_Switch的使用.html","title":"Switch的使用","keywords":"","body":"081_Switch的使用081_Switch的使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"082_解决样式丢失问题.html":{"url":"082_解决样式丢失问题.html","title":"解决样式丢失问题","keywords":"","body":"082_解决样式丢失问题082_解决样式丢失问题 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"083_路由的模糊匹配与严格匹配.html":{"url":"083_路由的模糊匹配与严格匹配.html","title":"路由的模糊匹配与严格匹配","keywords":"","body":"083_路由的模糊匹配与严格匹配083_路由的模糊匹配与严格匹配 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"084_Redirect的使用.html":{"url":"084_Redirect的使用.html","title":"Redirect的使用","keywords":"","body":"084_Redirect的使用084_Redirect的使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"085_嵌套路由.html":{"url":"085_嵌套路由.html","title":"嵌套路由","keywords":"","body":"085_嵌套路由085_嵌套路由 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"086_向路由组件传递.html":{"url":"086_向路由组件传递.html","title":"向路由组件传递","keywords":"","body":"086_向路由组件传递086_向路由组件传递 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"087_向路由组件传递search参数.html":{"url":"087_向路由组件传递search参数.html","title":"向路由组件传递search参数","keywords":"","body":"087_向路由组件传递search参数087_向路由组件传递search参数 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"088_向路由组件传递state参数.html":{"url":"088_向路由组件传递state参数.html","title":"向路由组件传递state参数","keywords":"","body":"088_向路由组件传递state参数088_向路由组件传递state参数 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"089_总结路由参数.html":{"url":"089_总结路由参数.html","title":"总结路由参数","keywords":"","body":"089_总结路由参数089_总结路由参数 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"090_.html":{"url":"090_.html","title":"090","keywords":"","body":"090_090_ new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"091_编程式路由导航.html":{"url":"091_编程式路由导航.html","title":"编程式路由导航","keywords":"","body":"091_编程式路由导航091_编程式路由导航 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"092_withRouter的使用.html":{"url":"092_withRouter的使用.html","title":"withRouter的使用","keywords":"","body":"092_withRouter的使用092_withRouter的使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"093_BrowserRouter与HashRouter.html":{"url":"093_BrowserRouter与HashRouter.html","title":"BrowserRouter与HashRouter","keywords":"","body":"093_BrowserRouter与HashRouter093_BrowserRouter与HashRouter new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"094_antd的基本使用.html":{"url":"094_antd的基本使用.html","title":"antd的基本使用","keywords":"","body":"094_antd的基本使用094_antd的基本使用 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"095_antd样式的按需引入.html":{"url":"095_antd样式的按需引入.html","title":"antd样式的按需引入","keywords":"","body":"095_antd样式的按需引入095_antd样式的按需引入 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"096_antd自定义主题.html":{"url":"096_antd自定义主题.html","title":"antd自定义主题","keywords":"","body":"096_antd自定义主题096_antd自定义主题 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"097_redux简介.html":{"url":"097_redux简介.html","title":"redux简介","keywords":"","body":"097_redux简介097_redux简介 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"098_redux工作流程.html":{"url":"098_redux工作流程.html","title":"redux工作流程","keywords":"","body":"098_redux工作流程098_redux工作流程 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"099_求和案例_纯react版.html":{"url":"099_求和案例_纯react版.html","title":"求和案例_纯react版","keywords":"","body":"099求和案例纯react版099求和案例纯react版 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"100_求和案例_redux精简版.html":{"url":"100_求和案例_redux精简版.html","title":"求和案例_redux精简版","keywords":"","body":"100_求和案例_redux精简版.md100_求和案例_redux精简版.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"101_求和案例_redux完整版.html":{"url":"101_求和案例_redux完整版.html","title":"求和案例_redux完整版","keywords":"","body":"101_求和案例_redux完整版.md101_求和案例_redux完整版.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"102_求和案例_异步action版.html":{"url":"102_求和案例_异步action版.html","title":"求和案例_异步action版","keywords":"","body":"102求和案例异步action版.md102求和案例异步action版.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"103_对react-redux的理解.html":{"url":"103_对react-redux的理解.html","title":"对react-redux的理解","keywords":"","body":"103_对react-redux的理解.md103_对react-redux的理解.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"104_连接容器组件与UI组件.html":{"url":"104_连接容器组件与UI组件.html","title":"连接容器组件与UI组件","keywords":"","body":"104_连接容器组件与UI组件.md104_连接容器组件与UI组件.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"105_react-redux基本使用.html":{"url":"105_react-redux基本使用.html","title":"react-redux基本使用","keywords":"","body":"105_react-redux基本使用.md105_react-redux基本使用.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"106_优化1_简写ma.html":{"url":"106_优化1_简写ma.html","title":"优化1_简写ma","keywords":"","body":"106优化1简写ma.md106优化1简写ma.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"107_优化2_.html":{"url":"107_优化2_.html","title":"优化2_","keywords":"","body":"107优化2.md107优化2.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"108_优化3_整合UI组件与容器组件.html":{"url":"108_优化3_整合UI组件与容器组件.html","title":"优化3_整合UI组件与容器组件","keywords":"","body":"108优化3整合UI组件与容器组件.md108优化3整合UI组件与容器组件.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"109_数据共享_编写.html":{"url":"109_数据共享_编写.html","title":"数据共享_编写","keywords":"","body":"109数据共享编写.md109数据共享编写.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"110_数据共享_编写.html":{"url":"110_数据共享_编写.html","title":"数据共享_编写","keywords":"","body":"110数据共享编写.md110数据共享编写.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"111_数据共享_完成数据共享.html":{"url":"111_数据共享_完成数据共享.html","title":"数据共享_完成数据共享","keywords":"","body":"111数据共享完成数据共享.md111数据共享完成数据共享.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"112_纯函数.html":{"url":"112_纯函数.html","title":"纯函数","keywords":"","body":"112_纯函数.md112_纯函数.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"113_redux开发者工具.html":{"url":"113_redux开发者工具.html","title":"redux开发者工具","keywords":"","body":"113_redux开发者工具.md113_redux开发者工具.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"114_最终版.html":{"url":"114_最终版.html","title":"最终版","keywords":"","body":"114_最终版.md114_最终版.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"115_项目打包运行.html":{"url":"115_项目打包运行.html","title":"项目打包运行","keywords":"","body":"115_项目打包运行.md115_项目打包运行.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"116_扩展1_setState.html":{"url":"116_扩展1_setState.html","title":"扩展1_setState","keywords":"","body":"116_扩展1_setState.md116_扩展1_setState.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"117_扩展2_lazyLoad.html":{"url":"117_扩展2_lazyLoad.html","title":"扩展2_lazyLoad","keywords":"","body":"117_扩展2_lazyLoad.md117_扩展2_lazyLoad.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"118_扩展3_stateHook.html":{"url":"118_扩展3_stateHook.html","title":"扩展3_stateHook","keywords":"","body":"118_扩展3_stateHook.md118_扩展3_stateHook.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"119_扩展4_EffectHook.html":{"url":"119_扩展4_EffectHook.html","title":"扩展4_EffectHook","keywords":"","body":"119_扩展4_EffectHook.md119_扩展4_EffectHook.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"120_扩展5_RefHook.html":{"url":"120_扩展5_RefHook.html","title":"扩展5_RefHook","keywords":"","body":"120_扩展5_RefHook.md120_扩展5_RefHook.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"121_扩展6_Fragment.html":{"url":"121_扩展6_Fragment.html","title":"扩展6_Fragment","keywords":"","body":"121_扩展6_Fragment.md121_扩展6_Fragment.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"122_扩展7_Context.html":{"url":"122_扩展7_Context.html","title":"扩展7_Context","keywords":"","body":"122_扩展7_Context.md122_扩展7_Context.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"123_扩展8_.html":{"url":"123_扩展8_.html","title":"扩展8_","keywords":"","body":"123扩展8.md123扩展8.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"124_扩展9_render.html":{"url":"124_扩展9_render.html","title":"扩展9_render","keywords":"","body":"124_扩展9_render.md124_扩展9_render.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"125_扩展10_ErrorBoundary.html":{"url":"125_扩展10_ErrorBoundary.html","title":"扩展10_ErrorBoundary","keywords":"","body":"125_扩展10_ErrorBoundary.md125_扩展10_ErrorBoundary.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"126_组件间通信方式总结.html":{"url":"126_组件间通信方式总结.html","title":"组件间通信方式总结","keywords":"","body":"126_组件间通信方式总结.md126_组件间通信方式总结.md new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "},"000_课件.html":{"url":"000_课件.html","title":"课件","keywords":"","body":" React全家桶(技术栈) 尚硅谷前端研究院 第1章：React入门 1.1. React简介 1.1.1. 官网 1. 英文官网: https://reactjs.org/ 2. 中文官网: https://react.docschina.org/ 1.1.2. 介绍描述 1. 用于动态构建用户界面的 JavaScript 库(只关注于视图) 2. 由Facebook开源 1.1.3. React的特点 1. 声明式编码 2. 组件化编码 3. React Native 编写原生应用 4. 高效（优秀的Diffing算法） 1.1.4. React高效的原因 1. 使用虚拟(virtual)DOM, 不总是直接操作页面真实DOM。 2. DOM Diffing算法, 最小化页面重绘。 1.2. React的基本使用 1.2.1. 效果   1.2.2. 相关js库 1. react.js：React核心库。 2. react-dom.js：提供操作DOM的react扩展库。 3. babel.min.js：解析JSX语法代码转为JS代码的库。 1.2.3. 创建虚拟DOM的两种方式   1. 纯JS方式(一般不用) 2. JSX方式 1.2.4. 虚拟DOM与真实DOM 1. React提供了一些API来创建一种 “特别” 的一般js对象 l const VDOM = React.createElement('xx',{id:'xx'},'xx') l 上面创建的就是一个简单的虚拟DOM对象 2. 虚拟DOM对象最终都会被React转换为真实的DOM 3. 我们编码时基本只需要操作react的虚拟DOM相关数据, react会转换为真实DOM变化而更新界。 1.3. React JSX 1.3.1. 效果   1.3.2. JSX 1. 全称:  JavaScript XML 2. react定义的一种类似于XML的JS扩展语法: JS + XML本质是React.createElement(component, props, ...children)方法的语法糖 3. 作用: 用来简化创建虚拟DOM 1) 写法：var ele = Hello JSX! 2) 注意1：它不是字符串, 也不是HTML/XML标签 3) 注意2：它最终产生的就是一个JS对象 4. 标签名任意: HTML标签或其它标签 5. 标签属性任意: HTML标签属性或其它 6. 基本语法规则 1) 遇到 开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析 2) 遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含 7. babel.js的作用 1) 浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行 2) 只要用了JSX，都要加上type=\"text/babel\", 声明需要babel来处理 1.3.3. 渲染虚拟DOM(元素) 1. 语法:  ReactDOM.render(virtualDOM, containerDOM) 2. 作用: 将虚拟DOM元素渲染到页面中的真实容器DOM中显示 3. 参数说明 1) 参数一: 纯js或jsx创建的虚拟dom对象 2) 参数二: 用来包含虚拟DOM元素的真实dom元素对象(一般是一个div) 1.3.4. JSX练习 需求: 动态展示如下列表   1.4. 模块与组件、模块化与组件化的理解 1.4.1. 模块 1. 理解：向外提供特定功能的js程序, 一般就是一个js文件 2. 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。 3. 作用：复用js, 简化js的编写, 提高js运行效率 1.4.2. 组件 1. 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等) 2. 为什么要用组件： 一个界面的功能更复杂 3. 作用：复用编码, 简化项目编码, 提高运行效率 1.4.3. 模块化 当应用的js都以模块来编写的, 这个应用就是一个模块化的应用 1.4.4. 组件化 当应用是以多组件的方式实现, 这个应用就是一个组件化的应用   第2章：React面向组件编程 2.1. 基本理解和使用 2.1.1. 使用React开发者工具调试   2.1.2. 效果 函数式组件：   类式组件：   2.1.3. 注意 1. 组件名必须首字母大写 2. 虚拟DOM元素只能有一个根元素 3. 虚拟DOM元素必须有结束标签 2.1.4. 渲染类组件标签的基本流程 1. React内部会创建组件实例对象 2. 调用render()得到虚拟DOM, 并解析为真实DOM 3. 插入到指定的页面元素内部 2.2. 组件三大核心属性1: state 2.2.1. 效果 需求: 定义一个展示天气信息的组件 1. 默认展示天气炎热 或 凉爽 2. 点击文字切换天气 2.2.2. 理解 1. state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合) 2. 组件被称为\"状态机\", 通过更新组件的state来更新对应的页面显示(重新渲染组件) 2.2.3. 强烈注意 1. 组件中render方法中的this为组件实例对象 2. 组件自定义的方法中this为undefined，如何解决？ a) 强制绑定this: 通过函数对象的bind() b) 箭头函数 3. 状态数据，不能直接修改或更新 2.3. 组件三大核心属性2: props 2.3.1. 效果 需求: 自定义用来显示一个人员信息的组件 1. 姓名必须指定，且为字符串类型； 2. 性别为字符串类型，如果性别没有指定，默认为男 3. 年龄为字符串类型，且为数字类型，默认值为18   2.3.2. 理解 1. 每个组件对象都会有props(properties的简写)属性 2. 组件标签的所有属性都保存在props中 2.3.3. 作用 1. 通过标签属性从组件外向组件内传递变化的数据 2. 注意: 组件内部不要修改props数据 2.3.4. 编码操作 1. 内部读取某个属性值 2. 对props中的属性值进行类型限制和必要性限制 第一种方式（React v15.5 开始已弃用）： 第二种方式（新）：使用prop-types库进限制（需要引入prop-types库） \t 3. 扩展属性: 将对象的所有属性通过props传递 4. 默认属性值： 5. 组件类的构造函数       2.4. 组件三大核心属性3: refs与事件处理 2.4.1. 效果 需求: 自定义组件, 功能说明如下:   1. 点击按钮, 提示第一个输入框中的值   2. 当第2个输入框失去焦点时, 提示这个输入框中的值 效果如下： 2.4.2. 理解 组件内的标签可以定义ref属性来标识自己 2.4.3. 编码 1. 字符串形式的ref 2. 回调形式的ref 3. createRef创建ref容器· 2.4.4. 事件处理 1. 通过onXxx属性指定事件处理函数(注意大小写) 1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) 2. 通过event.target得到发生事件的DOM元素对象 2.5. 收集表单数据 2.5.1. 效果 需求: 定义一个包含表单的组件   输入用户名密码后, 点击登录提示输入信息   2.5.2. 理解 包含表单的组件分类 1. 受控组件 2. 非受控组件 2.6. 组件的生命周期 2.6.1. 效果 需求:定义组件实现以下功能：   1. 让指定的文本做显示 / 隐藏的渐变动画   2. 从完全可见，到彻底消失，耗时2S   3. 点击“不活了”按钮从界面中卸载组件 2.6.2. 理解 1. 组件从创建到死亡它会经历一些特定的阶段。 2. React组件中包含一系列勾子函数(生命周期回调函数), 会在特定的时刻调用。 3. 我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作。 2.6.3. 生命周期流程图(旧)   生命周期的三个阶段（旧） \t1. 初始化阶段: 由ReactDOM.render()触发---初次渲染 1. constructor() 2. componentWillMount() 3. render() 4. componentDidMount() \t2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1. shouldComponentUpdate() 2. componentWillUpdate() 3. render() 4. componentDidUpdate() \t3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1. componentWillUnmount() 2.6.4. 生命周期流程图(新)   生命周期的三个阶段（新） 1. 初始化阶段: 由ReactDOM.render()触发---初次渲染 1. constructor() 2. getDerivedStateFromProps 3. render() 4. componentDidMount() \t2. 更新阶段: 由组件内部this.setSate()或父组件重新render触发 1. getDerivedStateFromProps 2. shouldComponentUpdate() 3. render() 4. getSnapshotBeforeUpdate 5. componentDidUpdate() \t3. 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 1. componentWillUnmount() 2.6.5. 重要的勾子 1. render：初始化渲染或更新渲染调用 2. componentDidMount：开启监听, 发送ajax请求 3. componentWillUnmount：做一些收尾工作, 如: 清理定时器 2.6.6. 即将废弃的勾子 1. componentWillMount 2. componentWillReceiveProps 3. componentWillUpdate 现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。 2.7. 虚拟DOM与DOM Diffing算法 2.7.1. 效果 需求：验证虚拟DOM Diffing算法的存在 2.7.2. 基本原理图   第3章：React应用(基于React脚手架) 3.1. 使用create-react-app创建react应用 3.1.1. react脚手架 1. xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目 1. 包含了所有需要的配置（语法检查、jsx编译、devServer…） 2. 下载好了所有相关的依赖 3. 可以直接运行一个简单效果 2. react提供了一个用于创建react项目的脚手架库: create-react-app 3. 项目的整体技术架构为:  react + webpack + es6 + eslint 4. 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化 3.1.2. 创建项目并启动 第一步，全局安装：npm i -g create-react-app 第二步，切换到想创项目的目录，使用命令：create-react-app hello-react 第三步，进入项目文件夹：cd hello-react 第四步，启动项目：npm start 3.1.3. react脚手架项目结构 \tpublic ---- 静态资源文件夹 \t\tfavicon.icon ------ 网站页签图标 \t\tindex.html -------- 主页面 \t\tlogo192.png ------- logo图 \t\tlogo512.png ------- logo图 \t\tmanifest.json ----- 应用加壳的配置文件 \t\trobots.txt -------- 爬虫协议文件 src ---- 源码文件夹 \t\tApp.css -------- App组件的样式 \t\tApp.js --------- App组件 \t\tApp.test.js ---- 用于给App做测试 \t\tindex.css ------ 样式 \t\tindex.js ------- 入口文件 \t\tlogo.svg ------- logo图 \t\treportWebVitals.js \t\t\t--- 页面性能分析文件(需要web-vitals库的支持) \t\tsetupTests.js \t\t\t---- 组件单元测试的文件(需要jest-dom库的支持) 3.1.4. 功能界面的组件化编码流程（通用） 1. 拆分组件: 拆分界面,抽取组件 2. 实现静态组件: 使用组件实现静态页面效果 3. 实现动态组件 3.1 动态显示初始化数据 3.1.1 数据类型 3.1.2 数据名称 3.1.2 保存在哪个组件? 3.2 交互(从绑定事件监听开始) 3.2. 组件的组合使用-TodoList 功能: 组件化实现此功能   1. 显示所有todo列表   2. 输入文本, 点击按钮显示到列表的首位, 并清除输入的文本 第4章：React ajax 4.1. 理解 4.1.1. 前置说明 1. React本身只关注于界面, 并不包含发送ajax请求的代码 2. 前端应用需要通过ajax请求与后台进行交互(json数据) 3. react应用中需要集成第三方ajax库(或自己封装) 4.1.2. 常用的ajax请求库 1. jQuery: 比较重, 如果需要另外引入不建议使用 2. axios: 轻量级, 建议使用 1) 封装XmlHttpRequest对象的ajax 2)  promise风格 3) 可以用在浏览器端和node服务器端 4.2. axios 4.2.1. 文档 https://github.com/axios/axios 4.2.2. 相关API 1) GET请求 axios.get('/user?ID=12345')   .then(function (response) {     console.log(response.data);   })   .catch(function (error) {     console.log(error);   });   axios.get('/user', {     params: {       ID: 12345     }   })   .then(function (response) {     console.log(response);   })   .catch(function (error) {     console.log(error);   });   2) POST请求 axios.post('/user', {   firstName: 'Fred',   lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 4.3. 案例—github用户搜索 4.3.1. 效果 请求地址: https://api.github.com/search/users?q=xxxxxx 4.4. 消息订阅-发布机制 1. 工具库: PubSubJS 2. 下载: npm install pubsub-js --save 3. 使用: 1) import PubSub from 'pubsub-js' //引入 2) PubSub.subscribe('delete', function(data){ }); //订阅 3) PubSub.publish('delete', data) //发布消息 4.5. 扩展：Fetch 4.5.1. 文档 1. https://github.github.io/fetch/ 2. https://segmentfault.com/a/1190000003810652 4.5.2. 特点 1. fetch: 原生函数，不再使用XmlHttpRequest对象提交ajax请求 2. 老版本浏览器可能不支持 4.5.3. 相关API 1) GET请求 fetch(url).then(function(response) {     return response.json()   }).then(function(data) {     console.log(data)   }).catch(function(e) {     console.log(e)   });   2) POST请求   fetch(url, {     method: \"POST\",     body: JSON.stringify(data),   }).then(function(data) {     console.log(data)   }).catch(function(e) {     console.log(e)   })   第5章：React路由 5.1. 相关理解 5.1.1. SPA的理解 1. 单页Web应用（single page web application，SPA）。 2. 整个应用只有一个完整的页面。 3. 点击页面中的链接不会刷新页面，只会做页面的局部更新。 4. 数据都需要通过ajax请求获取, 并在前端异步展现。 5.1.2. 路由的理解 1. 什么是路由? 1. 一个路由就是一个映射关系(key:value) 2. key为路径, value可能是function或component 2. 路由分类 1. 后端路由： 1) 理解： value是function, 用来处理客户端提交的请求。 2) 注册路由： router.get(path, function(req, res)) 3) 工作过程：当node接收到一个请求时, 根据请求路径找到匹配的路由, 调用路由中的函数来处理请求, 返回响应数据 2. 前端路由： 1) 浏览器端路由，value是component，用于展示页面内容。 2) 注册路由: 3) 工作过程：当浏览器的path变为/test时, 当前路由组件就会变为Test组件 5.1.3. react-router-dom的理解 1. react的一个插件库。 2. 专门用来实现一个SPA应用。 3. 基于react的项目基本都会用到此库。 5.2. react-router-dom相关API 5.2.1. 内置组件 1.  2.  3.  4.  5.  6.  7.  5.2.2. 其它 1. history对象 2. match对象 3. withRouter函数 5.3. 基本路由使用 5.3.1. 效果 5.3.2. 准备 1. 下载react-router-dom: npm install --save react-router-dom 2. 引入bootstrap.css: 5.4. 嵌套路由使用 效果 5.5. 向路由组件传递参数数据 效果 5.6. 多种路由跳转方式 效果 第6章：React UI组件库 6.1.流行的开源React UI组件库 6.1.1. material-ui(国外) 1. 官网: http://www.material-ui.com/#/ 2. github: https://github.com/callemall/material-ui 6.1.2. ant-design(国内蚂蚁金服) 1. 官网: https://ant.design/index-cn 2. Github: https://github.com/ant-design/ant-design/ 第7章：redux 7.1. redux理解 7.1.1. 学习文档 1. 英文文档: https://redux.js.org/ 2. 中文文档: http://www.redux.org.cn/ 3. Github: https://github.com/reactjs/redux 7.1.2. redux是什么 1. redux是一个专门用于做状态管理的JS库(不是react插件库)。 2. 它可以用在react, angular, vue等项目中, 但基本与react配合使用。 3. 作用: 集中式管理react应用中多个组件共享的状态。 7.1.3. 什么情况下需要使用redux 1. 某个组件的状态，需要让其他组件可以随时拿到（共享）。 2. 一个组件需要改变另一个组件的状态（通信）。 3. 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。 7.1.4. redux工作流程   7.2. redux的三个核心概念 7.2.1. action 1. 动作的对象 2. 包含2个属性 l type：标识属性, 值为字符串, 唯一, 必要属性 l data：数据属性, 值类型任意, 可选属性 3. 例子：{ type: 'ADD_STUDENT',data:{name: 'tom',age:18} } 7.2.2. reducer 1. 用于初始化状态、加工状态。 2. 加工时，根据旧的state和action， 产生新的state的纯函数。 7.2.3. store 1. 将state、action、reducer联系在一起的对象 2. 如何得到此对象? 1) import {createStore} from 'redux' 2) import reducer from './reducers' 3) const store = createStore(reducer) 3. 此对象的功能? 1) getState(): 得到state 2) dispatch(action): 分发action, 触发reducer调用, 产生新的state 3) subscribe(listener): 注册监听, 当产生了新的state时, 自动调用 7.3. redux的核心API 7.3.1. createstore() 作用：创建包含指定reducer的store对象 7.3.2. store对象 1. 作用: redux库最核心的管理对象 2. 它内部维护着: 1) state 2) reducer 3. 核心方法: 1) getState() 2) dispatch(action) 3) subscribe(listener) 4. 具体编码: 1) store.getState() 2) store.dispatch({type:'INCREMENT', number}) 3) store.subscribe(render) 7.3.3. applyMiddleware() 作用：应用上基于redux的中间件(插件库) 7.3.4. combineReducers() 作用：合并多个reducer函数 7.4. 使用redux编写应用  \t效果 7.5. redux异步编程 7.5.1理解： 1. redux默认是不能进行异步处理的, 2. 某些时候应用中需要在redux中执行异步任务(ajax, 定时器) 7.5.2. 使用异步中间件 npm install --save redux-thunk 7.6. react-redux 7.6.1. 理解 1. 一个react插件库 2. 专门用来简化react应用中使用redux 7.6.2. react-Redux将所有组件分成两大类 1. UI组件 1) 只负责 UI 的呈现，不带有任何业务逻辑 2) 通过props接收数据(一般数据和函数) 3) 不使用任何 Redux 的 API 4) 一般保存在components文件夹下 2. 容器组件 1) 负责管理数据和业务逻辑，不负责UI的呈现 2) 使用 Redux 的 API 3) 一般保存在containers文件夹下 7.6.3. 相关API 1. Provider：让所有组件都可以得到state数据 2. connect：用于包装 UI 组件生成容器组件 3. mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性 4. mapDispatchToProps：将分发action的函数转换为UI组件的标签属性 7.7. 使用上redux调试工具 7.7.1. 安装chrome浏览器插件   7.7.2. 下载工具依赖包 \tnpm install --save-dev redux-devtools-extension   7.8. 纯函数和高阶函数 7.8.1. 纯函数 1. 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回) 2. 必须遵守以下一些约束   1) 不得改写参数数据 2) 不会产生任何副作用，例如网络请求，输入和输出设备 3) 不能调用Date.now()或者Math.random()等不纯的方法   3. redux的reducer函数必须是一个纯函数 7.8.2. 高阶函数 1. 理解: 一类特别的函数 1) 情况1: 参数是函数 2) 情况2: 返回是函数 2. 常见的高阶函数: 1) 定时器设置函数 2) 数组的forEach()/map()/filter()/reduce()/find()/bind() 3) promise 4) react-redux中的connect函数 3. 作用: 能实现更加动态, 更加可扩展的功能 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-03-28 19:41:55 "}}